[
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Domain Separation Collision - CRITICAL] Can an attacker exploit the naive concatenation of dst and data in hash_to_F to create signature forgery by finding dst='FROST-RISTRETTO255-SHA512-v11', data='nonce' that collides with dst='FROST-RISTRETTO255-SHA512-v11nonce', data='', allowing cross-protocol replay attacks between FROST nonce generation and other protocol phases? [Severity: CRITICAL]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Domain Separation Collision - CRITICAL] If two different Serai subsystems use dst values where one is a substring prefix of another (e.g., 'FROST-DKG' and 'FROST-DKG-ROUND2'), can an attacker transpose the boundary to forge scalars that appear valid in both contexts, potentially compromising threshold signature security? [Severity: CRITICAL]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Cross-Protocol Attack - HIGH] Given that hash_to_F performs [dst, data].concat(), can an attacker craft messages where dst ends with specific bytes and data begins with specific bytes to collide with a different (dst, data) pair used in FROST signing, allowing challenge scalar forgery? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Binding Factor Manipulation - CRITICAL] In FROST threshold signing, if binding factors are computed using hash_to_F with different dst/data boundaries than expected, can this lead to binding factor collisions that allow signature forgery with fewer than threshold participants? [Severity: CRITICAL]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [DKG Share Compromise - HIGH] During FROST DKG, if share commitments or VSS proofs use hash_to_F with manipulable dst/data boundaries, can an attacker create fake shares that pass verification but allow key extraction or rogue key attacks? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Nonce Reuse Attack - CRITICAL] Can the dst/data transposition vulnerability in hash_to_F cause the same nonce scalar to be derived in different FROST signing sessions, enabling private key extraction via nonce reuse across two signatures? [Severity: CRITICAL]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Challenge Collision - CRITICAL] For Schnorr signature challenges computed via hash_to_F, can an attacker find two different messages that produce the same challenge scalar by exploiting dst/data boundary manipulation, enabling existential forgery? [Severity: CRITICAL]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Multi-Network Collision - HIGH] Since Serai supports multiple networks (Bitcoin, Ethereum, Monero), can an attacker craft a transaction instruction on Network A that when hashed via hash_to_F produces the same scalar as a different instruction on Network B, causing cross-chain replay or mint/burn imbalance? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Processor-Coordinator Confusion - HIGH] If the coordinator and processor use different dst conventions for batch signing, can the dst/data concatenation vulnerability cause them to derive different scalars for the same logical operation, leading to signing failures or stuck batches? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Version Collision - MEDIUM] Can an attacker exploit protocol version strings in dst (e.g., 'v11' vs 'v1') to create collisions with data fields, allowing cross-version replay attacks when validator sets upgrade their FROST implementation? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Constant: ID] [Ciphersuite Confusion - HIGH] The Ristretto ciphersuite uses ID b'ristretto' while Ed25519 uses b'edwards25519'. If a validator accidentally mixes these IDs in multi-signature aggregation, can this lead to invalid signatures being accepted or valid signatures being rejected, causing batch signing failures? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Constant: ID] [Cross-Curve Attack - CRITICAL] Can an attacker submit a FROST signature generated with the Ristretto ciphersuite but claim it was generated with Ed25519 (or vice versa), causing validators to verify signatures on the wrong curve group and potentially accept forged signatures? [Severity: CRITICAL]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Constant: ID] [Network Binding - MEDIUM] Are ciphersuite IDs properly bound to network identifiers? Can an attacker replay a signature generated for Bitcoin (using Ristretto) on the Monero network if both use the same ciphersuite, bypassing network-specific validation? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Constant: ID] [Protocol Extension Attack - MEDIUM] If future protocol versions add new ciphersuites with similar ID prefixes (e.g., 'ristretto' and 'ristretto2'), can the lack of length prefixing or delimiters in ID comparison lead to ciphersuite confusion attacks? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: generator()] [Generator Substitution - CRITICAL] The generator() function simply returns Point::generator(). If an attacker can somehow influence or cache-poison the generator point during initialization, can this lead to all derived public keys and signatures being compromised? [Severity: CRITICAL]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: generator()] [Subgroup Attack - HIGH] Does the implementation verify that generator() returns a point of prime order? Can an attacker exploit a small-order generator to perform subgroup confinement attacks on FROST signatures, leaking key material? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: generator()] [Determinism - MEDIUM] Is generator() guaranteed to return the same canonical generator across all validator instances? Could non-deterministic generator selection cause validators to derive different multisig public keys, breaking consensus? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Type: Scalar] [Reduction Attack - HIGH] When hash_to_F produces a Scalar via from_hash(), is the reduction modulo the curve order performed correctly? Can an attacker find hash inputs that produce weak scalars (e.g., zero or near-zero) that break FROST signature security? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Type: Scalar] [Bias Attack - MEDIUM] Does Scalar::from_hash() produce uniformly distributed scalars, or is there exploitable bias that could allow an attacker to predict nonces or binding factors in FROST signing with higher probability than 1/q? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Zero Scalar DoS - MEDIUM] Can an attacker craft dst/data inputs to hash_to_F that produce a zero scalar, causing FROST signing to fail with a division-by-zero or invalid signature, enabling targeted DoS against specific batches? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Scalar Overflow - LOW] Although Scalar::from_hash() should handle reduction, are there edge cases with maximum-sized hash outputs where overflow or wraparound could occur, producing incorrect scalars? [Severity: LOW]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Timing Side-Channel - MEDIUM] The concatenation [dst, data].concat() and subsequent hashing may have data-dependent timing. Can an attacker use timing measurements to distinguish between different dst or data values, leaking information about FROST nonce commitments or private signing operations? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Cache Timing Attack - MEDIUM] Does the Sha512 hash implementation have constant-time guarantees? Can cache-timing attacks on hash_to_F reveal partial information about secret scalars used in DKG or threshold signing? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: generator()] [Timing Leak - LOW] If generator() performs any point validation or decompression, can timing analysis reveal whether a validator is using a standard or custom generator, potentially leaking validator identity? [Severity: LOW]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Derive: Zeroize] [Memory Leak - MEDIUM] Both Ristretto and Ed25519 derive Zeroize, but does this actually zeroize sensitive intermediate values in hash_to_F, such as the concatenated [dst, data] buffer, before deallocation? [Severity: MEDIUM]"
]