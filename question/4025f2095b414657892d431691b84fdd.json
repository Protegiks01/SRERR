[
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Secret Persistence - MEDIUM] The concatenated buffer [dst, data].concat() is not explicitly zeroized after hashing. If dst or data contain secret values (e.g., nonce seeds), can this lead to secrets persisting in memory and being recovered via memory dumps? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Derive: Zeroize] [Incomplete Zeroization - LOW] Are all intermediate Scalar values produced by from_hash() properly zeroized when they go out of scope, or can compiler optimizations eliminate zeroization, leaving key material in memory? [Severity: LOW]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Test: test_ristretto()] [Test Coverage - HIGH] The test vector uses a FROST-specific dst 'FROST-RISTRETTO255-SHA512-v11nonce'. Does this provide adequate coverage for Serai-specific dst values used in production, or could production dst values have vulnerabilities not caught by this test? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Test: test_ed25519()] [Missing Vectors - MEDIUM] The comment states 'Ideally, a test vector from RFC-8032 (not FROST) would be here'. Without RFC-8032 test vectors, could there be an implementation bug in hash_to_F for Ed25519 that diverges from the standard and causes interoperability failures? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Test: test_ristretto()] [Collision Testing - MEDIUM] Do the tests verify that different (dst, data) pairs produce different scalars, particularly for the documented collision case where dst='abc', data='def' collides with dst='abcdef', data=''? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Test: test_ed25519()] [Cross-Ciphersuite Testing - LOW] Are there tests that verify Ristretto and Ed25519 produce different outputs for the same inputs, preventing accidental cross-ciphersuite usage? [Severity: LOW]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Macro: dalek_curve!] [Type Confusion - MEDIUM] The macro uses generic Point types ($Point). If the wrong Point type is passed (e.g., RistrettoPoint used with Ed25519 ID), can this cause type confusion that compiles but produces cryptographically invalid operations? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Macro: dalek_curve!] [Feature Flag Mismatch - MEDIUM] The macro includes a $feature parameter but doesn't visibly use it. If feature flags controlling curve implementations are misconfigured, can this lead to runtime panics or wrong-curve operations? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Macro: dalek_curve!] [Namespace Collision - LOW] The macro imports `use crate::$Point;`. If multiple curves are enabled simultaneously, can name collisions or shadowing cause the wrong Point type to be used? [Severity: LOW]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Binding Factor Forgery - CRITICAL] In FROST signing, binding factors must be unique per signing session. Can the dst/data collision vulnerability allow an attacker to force the same binding factor across different signing sessions, enabling signature forgery? [Severity: CRITICAL]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Commitment Manipulation - HIGH] FROST nonce commitments are derived using hash_to_F. Can an attacker exploit the concatenation vulnerability to predict commitments or create commitment collisions, breaking the commitment scheme's hiding property? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Preprocess Reuse - CRITICAL] If FROST preprocess values (nonces) are derived via hash_to_F and the dst/data boundary is manipulated, can this cause nonce reuse across different messages, immediately leaking the private key share? [Severity: CRITICAL]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [DLEq Proof Bypass - HIGH] FROST uses DLEq (Discrete Log Equality) proofs for nonce correctness. If the challenge for DLEq proofs is computed via hash_to_F with manipulable inputs, can an attacker forge proofs and contribute malicious nonce shares? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Threshold Bypass - CRITICAL] Can collisions in binding factors or challenges derived from hash_to_F allow an attacker to aggregate fewer than threshold signature shares and still produce a valid multisignature? [Severity: CRITICAL]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Batch ID Collision - HIGH] If batch IDs are hashed into signing challenges via hash_to_F, can the dst/data transposition cause two different batches to have the same challenge, allowing replay of signatures across batches? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Plan Substitution - HIGH] Processors create signing plans that are hashed for coordinator verification. Can dst/data manipulation cause a malicious plan to hash to the same value as a legitimate plan, bypassing validation? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Block Hash Collision - MEDIUM] External chain block hashes are incorporated into Serai signatures. Can hash_to_F transposition cause different block hashes to map to the same scalar, allowing reorg attacks or batch replay? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Instruction Hash Collision - HIGH] Serai Instructions are hashed for signature binding. Can the dst/data vulnerability cause two different instructions (e.g., mint vs burn) to produce the same hash, allowing instruction substitution after signing? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Network Confusion - HIGH] Different networks (Bitcoin, Ethereum, Monero) may use different instruction formats. Can dst/data transposition cause an instruction valid on one network to collide with an instruction on another network, enabling cross-network replay? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Refund Bypass - MEDIUM] If refund addresses are hashed into instruction commitments via hash_to_F, can an attacker manipulate the dst/data boundary to make a non-refundable instruction appear refundable, causing fund loss? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Swap Hash Collision - HIGH] DEX swap operations are signed by the multisig. If swap parameters are hashed via hash_to_F, can dst/data manipulation cause two different swaps (with different amounts or rates) to have the same signature, enabling swap substitution? [Severity: HIGH]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Liquidity Manipulation - MEDIUM] Liquidity pool operations (add/remove liquidity) may involve signatures. Can hash_to_F collisions allow an attacker to modify liquidity amounts after obtaining signatures, draining pools? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Fee Calculation Bypass - MEDIUM] If transaction fees are incorporated into signature challenges, can dst/data transposition allow an attacker to avoid fees or pay reduced fees while reusing a valid signature? [Severity: MEDIUM]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Set ID Collision - CRITICAL] Validator set transitions use set IDs in key derivation. Can hash_to_F transposition cause two different validator sets to derive the same multisig key, allowing old validators to spend new validator funds? [Severity: CRITICAL]",
  "[File: serai/crypto/dalek-ff-group/src/ciphersuite.rs] [Function: hash_to_F()] [Rotation Attack - HIGH] During validator set rotation, can an attacker exploit dst/data manipulation to make new-set signatures appear as old-set signatures, enabling double-signing or bypassing rotation security? [Severity: HIGH]"
]