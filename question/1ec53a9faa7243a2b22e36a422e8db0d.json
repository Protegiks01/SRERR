[
  "[File: serai/crypto/frost/src/algorithm.rs] [Trait: Algorithm] [Critical - Threshold Assumption] Does the trait assume t = 2n/3 + 1 threshold as specified in Serai docs? Can lower thresholds break security?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Algorithm::verify()] [High - Subgroup Attack] If fewer than t shares are aggregated, can the verification still succeed and accept invalid signatures?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Algorithm::sign_share()] [Medium - Share Independence] Is each share independently verifiable before aggregation to detect malicious participants early?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Trait: Algorithm] [High - DKG Output Binding] How is the Algorithm bound to the DKG output keys? Can mismatched keys/algorithms enable forgery?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Algorithm::preprocess_addendum()] [High - Key Validation] Does preprocess_addendum validate that keys are properly formed DKG outputs with proof-of-knowledge?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Struct: ThresholdKeys] [Medium - Key Storage] Are ThresholdKeys properly zeroized when dropped to prevent key leakage?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Algorithm::nonces()] [Critical - Nonce Uniqueness Per Session] Can the same nonce value be generated across different signing sessions, enabling key extraction through the nonce reuse attack?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Schnorr::nonces()] [High - Single Generator Limitation] Is using only C::generator() sufficient, or can some attack scenarios (like multi-signature schemes) require additional generators?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Algorithm::sign_share()] [High - Nonce Combination Correctness] Is the 'd + (e * p)' nonce combination formula correctly implemented? Can incorrect binding factor 'e' calculation enable Wagner's attack?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Schnorr::sign_share()] [High - Nonce Commitment Binding] Is the nonce commitment R cryptographically bound to prevent nonce substitution after commitment?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Schnorr::sign_share()] [Critical - Challenge Calculation Order] Is the challenge calculated after all nonce commitments are collected? Can early challenge calculation enable adaptive chosen-message attacks?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Trait: Hram::hram()] [Critical - Challenge Input Ordering] Does H::hram(R, A, m) use a canonical input ordering? Can different orderings produce the same challenge and enable collision attacks?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Schnorr::sign_share()] [High - Challenge Serialization] How is the challenge serialized when passed to SchnorrSignature::sign()? Can malleability in serialization enable forgery?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Struct: Schnorr] [High - Challenge Storage Duration] How long is self.c stored? Can it be accessed or modified between sign_share() and verify()?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Algorithm::verify()] [Critical - Share Aggregation] Is the sum parameter the correct aggregation of all signature shares? Can partial aggregations pass verification?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Algorithm::verify_share()] [High - Batch Verification Optimization] Does batch verification correctly check multiple shares? Can batching errors cause invalid shares to be accepted?",
  "[File: serai/crypto/frost/src/algorithm.rs] [Function: Schnorr::verify_share()] [Medium - Verification Equation] Does the batch_statements verification equation match the standard Schnorr verification (sG = R + cA)?",
  "[File: serai/\n\n### Citations\n\n**File:** crypto/frost/src/algorithm.rs (L1-231)\n```rust\nuse core::{marker::PhantomData, fmt::Debug};\nuse std::io::{self, Read, Write};\n\nuse zeroize::Zeroizing;\nuse rand_core::{RngCore, CryptoRng};\n\nuse transcript::Transcript;\n\nuse crate::{Participant, ThresholdKeys, ThresholdView, Curve, FrostError};\npub use schnorr::SchnorrSignature;\n\n/// Write an addendum to a writer.\npub trait WriteAddendum {\n  fn write<W: Write>(&self, writer: &mut W) -> io::Result<()>;\n}\n\nimpl WriteAddendum for () {\n  fn write<W: Write>(&self, _: &mut W) -> io::Result<()> {\n    Ok(())\n  }\n}\n\n/// Trait alias for the requirements to be used as an addendum.\npub trait Addendum: Send + Sync + Clone + PartialEq + Debug + WriteAddendum {}\nimpl<A: Send + Sync + Clone + PartialEq + Debug + WriteAddendum> Addendum for A {}\n\n/// Algorithm trait usable by the FROST signing machine to produce signatures..\npub trait Algorithm<C: Curve>: Send + Sync {\n  /// The transcript format this algorithm uses. This likely should NOT be the IETF-compatible\n  /// transcript included in this crate.\n  type Transcript: Sync + Clone + Debug + Transcript;\n  /// Serializable addendum, used in algorithms requiring more data than just the nonces.\n  type Addendum: Addendum;\n  /// The resulting type of the signatures this algorithm will produce.\n  type Signature: Clone + PartialEq + Debug;\n\n  /// Obtain a mutable borrow of the underlying transcript.\n  fn transcript(&mut self) -> &mut Self::Transcript;\n\n  /// Obtain the list of nonces to generate, as specified by the generators to create commitments\n  /// against per-nonce.\n  ///\n  /// The Algorithm is responsible for all transcripting of these nonce specifications/generators.\n  ///\n  /// The prover will be passed the commitments, and the commitments will be sent to all other\n  /// participants. No guarantees the commitments are internally consistent (have the same discrete\n  /// logarithm across generators) are made. Any Algorithm which specifies multiple generators for\n  /// a single nonce must handle that itself.\n  fn nonces(&self) -> Vec<Vec<C::G>>;\n\n  /// Generate an addendum to FROST"
]