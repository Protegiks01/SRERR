[
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::view()] [HashMap Ordering] At line 500, verification_shares HashMap is populated in a loop. Could the iteration order of included affect the final result due to HashMap non-determinism? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::write()] [Verification Shares Order] At lines 556-560, verification shares are written in strict order 1..=n. Could reading from a different order or with missing entries cause deserialization issues? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Struct: ThresholdCore] [HashMap vs BTreeMap] At line 261, verification_shares is a HashMap. Could using HashMap instead of BTreeMap cause non-deterministic serialization or consensus issues? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::view()] [Offset Single-Point Failure] At lines 518-521, the offset is only applied to the lowest-ID participant. If that participant is Byzantine or censored, can the protocol still function correctly? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::scale()] [Scalar Rejection] At line 401-402, zero scalars are rejected with None. Could an attacker force zero scalars in specific scenarios to DoS key derivation? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::new()] [Interpolation Mismatch] At lines 368-374, constant interpolation requires t == n. Could an attacker exploit this by providing constant interpolation for threshold protocols expecting Lagrange? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: Interpolation::interpolation_factor()] [Lagrange Edge Cases] At lines 229-247, Lagrange interpolation requires all participants in included to be distinct. Could duplicate prevention failures in view() cause issues here? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: AllParticipantIndexes::next()] [Unwrap Safety] At line 151, unwrap() is called on Participant::new(self.i). Could self.i ever be 0 due to underflow or state corruption? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::view()] [Last Element Unwrap] At line 487, included.last().unwrap() assumes included is non-empty. Is this guaranteed by the length check at lines 464-471? (Low)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::write()] [TryFrom Unwrap] At line 539, try_from().unwrap() is called on C::ID.len(). Could a ciphersuite with ID length > u32::MAX cause a panic here? (Low)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::serialize()] [Write Unwrap] At line 569, write() is called with unwrap(). Could writing to a Vec<u8> ever fail and panic? (Low)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::group_key()] [Key Derivation Formula] At line 446, the formula (key * scalar) + (generator * offset) is used. Is this formula consistent with the secret share derivation in view() at lines 494-520? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::view()] [Interpolation Order] At lines 494-498, the secret share is scaled then interpolated. Is this order consistent with how verification shares are computed at lines 502-506? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::view()] [Verification Share Formula] At lines 503-505, verification shares are computed as: verification_share * scalar * interpolation_factor. Is this mathematically equivalent to the secret share computation? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: Interpolation::interpolation_factor()] [Lagrange Formula] At lines 232-246, the Lagrange formula computes product(share) / product(share - i_f). Is this the correct Lagrange interpolation formula for threshold signatures? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::new()] [Group Key Validation] At lines 376-378, the group key is derived using the first t participants. Should it use all n participants or specifically the signing set? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::view()] [Empty Included List] What if included is empty after validation at lines 464-471? Could this cause issues at line 518 when accessing included[0]? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdParams::new()] [Minimum Threshold] At lines 167-172, there's no check for minimum viable threshold (e.g., t >= 2). Could t=1 with n>1 allow single-party control while appearing to be a multisig? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::new()] [Verification Shares Completeness] At lines 355-365, the code checks the count and IDs of verification shares, but does it check for gaps (e.g., participants 1,2,4,5 when n=5)? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::view()] [Included Ordering] At line 473, included is sorted. Could the original order be significant for protocol purposes, and does sorting break anything? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: Interpolation::interpolation_factor()] [Zero Participant] Although Participant prevents ID 0, at line 230 what if field conversion of a valid participant ID results in F::ZERO due to field modulus? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Struct: ThresholdCore] [Cloning Secrets] At line 257, ThresholdCore derives Clone. Could cloning create multiple copies of secret_share that aren't properly zeroized? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Struct: ThresholdKeys] [Clone Semantics] At line 291, ThresholdKeys derives Clone. Does cloning an Arc mean multiple ThresholdKeys can share the same core, and does this affect zeroization? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::view()] [Participant ID Manipulation] At lines 494-521, if an attacker can manipulate the included list to exclude the participant with lowest ID, could they prevent offset application and derive incorrect keys? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::scale()] [Multiple Scale Calls] If scale() is called multiple times, self.scalar is multiplied repeatedly at line 404. Could accumulated multiplications lead to predictable patterns or weak keys? (Medium)"
]