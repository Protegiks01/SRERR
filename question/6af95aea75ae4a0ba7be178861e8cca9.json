[
  "[File: serai/crypto/dkg/src/lib.rs] [Function: Participant::new()] [Input Validation] Can an attacker create a Participant with ID 0 through unsafe code or memory manipulation, bypassing the validation check at line 30, leading to division-by-zero or invalid key derivation? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: Participant::new()] [Denial of Service] Does the None return at line 31 when i==0 propagate properly through all call sites, or could unwrap() calls on None cause panics during DKG protocol execution? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: Participant::to_bytes()] [Endianness] Could the little-endian encoding at line 40 cause cross-platform incompatibilities or signature verification failures when validators run on different architectures? (Low)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: From<Participant> for u16] [Type Conversion] Can converting Participant back to u16 at line 46 be exploited if the internal value was corrupted through unsafe memory operations? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: borsh::BorshDeserialize for Participant] [Deserialization] At line 123, if deserializing from untrusted input, can an attacker provide u16::MAX or boundary values that pass deserialization but cause issues in subsequent DKG operations? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdParams::new()] [Threshold Validation] At line 167-168, the check (t == 0) || (n == 0) rejects zero parameters, but does it handle the case where t = 1 and n = 1, which might allow single-party 'multisig' control? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdParams::new()] [Threshold Validation] At line 171, can an attacker exploit the boundary condition where t == n to bypass economic security requirements or enable non-threshold signing? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdParams::new()] [Participant Bounds] At line 174, the check i.0 > n could be bypassed if i.0 was manipulated to equal n exactly when n is at u16::MAX, causing off-by-one errors in array indexing? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdParams::new()] [Integer Overflow] If t and n are both u16::MAX, could subsequent arithmetic operations (like t+1 or 2*t) overflow when computing actual threshold requirements? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdParams::all_participant_indexes()] [Iterator Bounds] At lines 153-158, the special handling for i == u16::MAX setting n=0 could cause issues if an iterator is created mid-iteration - can this lead to skipped participants? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: AllParticipantIndexes::next()] [Iteration Logic] At line 148, the condition i > n returns None, but at line 151 unwrap() is called - could this panic if Participant::new(i) somehow returns None due to state corruption? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: borsh::BorshDeserialize for ThresholdParams] [Deserialization Attack] At line 206, the deserialization calls ThresholdParams::new() which validates parameters, but could an attacker craft serialized data that passes validation but causes issues when used in actual DKG? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: Interpolation::interpolation_factor()] [Constant Interpolation] At line 228, accessing c[usize::from(u16::from(i) - 1)] could panic if i is 0 (despite Participant preventing this) or if the coefficient vector is shorter than expected. Can this be exploited? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: Interpolation::interpolation_factor()] [Lagrange Interpolation] At lines 230-246, if two participants have the same ID in the included list, the denominator at line 241 becomes zero, and invert().unwrap() at line 246 panics. Does duplicate detection happen before this? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: Interpolation::interpolation_factor()] [Division by Zero] At line 246, the comment says 'Safe as this will only be 0 if we're part of the above loop', but could a malicious participant manipulation or race condition cause denom to be zero? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: Interpolation::interpolation_factor()] [Field Arithmetic] At lines 239-241, the multiplication num *= share and denom *= share - i_f could overflow in certain field implementations. Are field operations guaranteed to be modular? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: Interpolation::interpolation_factor()] [Side Channel] The loop at lines 234-242 has a timing-dependent branch (continue at line 236) that could leak information about participant IDs through timing analysis. Is this constant-time safe? (Low)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::new()] [Verification Shares Count] At line 355, the check verification_shares.len() != usize::from(params.n()) rejects incorrect counts, but does it handle the case where n is 0 or u16::MAX causing integer issues? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::new()] [Participant Validation] At lines 361-365, the loop checks if participant IDs exceed params.n(), but what if the HashMap contains fewer unique participants than n due to hash collisions or corruption? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::new()] [Interpolation Validation] At lines 368-371, constant interpolation requires t == n, but does this check prevent an attacker from providing constant coefficients for a threshold where t < n, potentially allowing unauthorized signing? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::new()] [Group Key Derivation] At lines 376-378, the group_key is computed by summing interpolated verification shares for participants 1 to t. What if t is larger than n or if Participant(i) creates invalid IDs? (Critical)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::new()] [Missing Verification Shares] At line 378, accessing verification_shares[i] could panic if the HashMap doesn't contain all participants 1..=t. Is this checked before the sum operation? (High)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::new()] [Key Material Storage] At lines 381-387, ThresholdCore is wrapped in Arc<Zeroizing<...>>, but does the Arc prevent proper zeroization on drop if there are multiple references? (Medium)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::new()] [Default Values] At lines 388-389, scalar is set to ONE and offset to ZERO. Could a race condition or memory corruption cause these to be non-default before serialization? (Low)",
  "[File: serai/crypto/dkg/src/lib.rs] [Function: ThresholdKeys::scale()] [Zero Scalar] At lines 401-402, if scalar is zero, None is returned. Do all callers handle this None properly, or could unwrap() cause panics during transaction signing? (High)"
]