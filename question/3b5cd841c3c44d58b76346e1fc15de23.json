[
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: TransactionSignMachine::sign()] [Critical - Share Collection] Lines 377-395 collect shares in a Vec - if shares.push occurs after an early return from ?, could partial shares be created without corresponding signature machines? (Critical)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: TransactionSignMachine::cache()] [Medium - Unimplemented Panic] Lines 333-337 use unimplemented!() for cache - if any code path accidentally calls this, it causes an immediate panic and potential DoS. (Medium)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: TransactionSignMachine::from_cache()] [Medium - Unimplemented Panic] Lines 340-348 use unimplemented!() for from_cache - could coordinator retry logic accidentally call this and crash the processor? (Medium)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: TransactionSignatureMachine::complete()] [Critical - Share Ordering] Line 419 uses shares.remove(0) to get shares in order - if participants send shares in different orders, could this cause signatures to be assembled incorrectly? (Critical)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: TransactionSignatureMachine::complete()] [High - Witness Size] Lines 422-424 create a witness with a single signature - if the signature is not exactly 64 bytes due to encoding, does this cause transaction invalidity? (High)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: TransactionSignatureMachine::complete()] [Critical - Input Mutation] Line 417 mutates self.tx.input iteratively - if complete() is called twice, does it append duplicate witnesses or panic? (Critical)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: TransactionSignatureMachine::complete()] [High - Signature Verification] complete() assembles signatures but doesn't verify them - could malformed shares pass through and create an invalid Bitcoin transaction? (High)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: TransactionSignatureMachine::complete()] [Medium - Iterator Exhaustion] Line 417 zips input.iter_mut() with sigs.drain(..) - if these have different lengths due to bugs, does the zip silently truncate or panic? (Medium)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Cross-Function] [Critical - Key-Script Binding] If tweak_keys() at line 46 and p2tr_script_buf() at line 80 use different elliptic curve implementations, could they produce incompatible keys and scripts, making funds unspendable? (Critical)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Cross-Function] [High - Offset Consistency] ReceivedOutput stores offsets at line 92, Scanner::register_offset validates them at line 180, but does SignableTransaction::multisig at line 273 verify offsets haven't been tampered with? (High)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Cross-Function] [Critical - Fee Race Condition] If SignableTransaction::new() calculates fees at line 206 but the transaction is signed later, could network fee rates change causing the transaction to be stuck in mempool indefinitely? (Critical)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Cross-Function] [High - State Machine Transition] The state machine transitions from TransactionMachine -> TransactionSignMachine -> TransactionSignatureMachine - if any transition fails, is partial state cleaned up or could it leak sensitive nonces? (High)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: tweak_keys()] [High - Side Channel] Does the conditional_select at lines 69-73 run in constant time, or could timing attacks reveal whether keys were negated? (High)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: TransactionSignMachine::sign()] [Critical - Nonce Leakage] If taproot_key_spend_signature_hash at line 386 fails after nonces are committed but before signing completes, are the nonces safely disposed or could they be reused? (Critical)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::register_offset()] [High - Timing Side Channel] The loop at lines 184-195 takes variable time based on how many increments are needed - could an attacker measure this timing to learn about the offset? (High)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::scan_block()] [Medium - Concurrent Scanning] If multiple threads scan the same block simultaneously, could they produce duplicate ReceivedOutputs that cause double-counting of deposits? (Medium)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [High - Reentrancy] If new() is called reentrantly with overlapping inputs, could the inputs.drain at line 253 cause one transaction to steal inputs from another? (High)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: ReceivedOutput::serialize()] [Low - Panic on Write] Line 146 uses unwrap() on write result - could this panic if the Vec allocation fails, causing validator crash? (Low)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [High - Panic on Checked Math] Line 199 uses expect() on try_from for data - if this path is reachable, it causes a panic instead of returning TransactionError::TooMuchData. (High)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: tweak_keys()] [Critical - Panic on Zero] Line 74 expects scaling by Â±1 never produces zero, but if subtle::ConditionallySelectable has a bug, could this panic during validator set initialization? (Critical)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: ReceivedOutput::write()] [Medium - Endianness] Lines 138-140 serialize offset, output, outpoint - are these all little-endian/big-endian consistent with Bitcoin's encoding? (Medium)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::txid()] [High - Byte Order] Line 261 reverses txid bytes - is this consistently applied everywhere txids are compared, or could big-endian/little-endian confusion cause transaction mismatches? (High)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [High - Fee Griefing] If fee_per_vbyte at line 155 is set very low, line 211-213 checks against DEFAULT_MIN_RELAY_TX_FEE - could an attacker force validators to create unrelayable transactions? (High)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [Critical - DUST Attack] An attacker could deposit many outputs just above DUST (547 sats) then later withdraw, forcing validators to spend many inputs with high fees - is there UTXO consolidation logic? (Critical)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [High - Change Address Griefing] If change address is None at line 153, all excess becomes fee - could an attacker manipulate inputs to force no change output and burn user funds? (High)"
]