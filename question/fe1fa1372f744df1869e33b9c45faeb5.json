[
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::new()] [High - Key Reuse] Does Scanner::new verify that the provided key hasn't been used before, or could reusing a key across validator sets cause transaction confusion? (High)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::register_offset()] [Critical - Infinite Loop DoS] Lines 184-195 have a loop that increments offset until an even point is found - if an attacker provides an offset that leads to a cycle or if the RNG is broken, could this loop forever? (Critical)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::register_offset()] [High - Offset Collision] At line 187-189, if a script already exists, None is returned - but what if two legitimate payment channels independently derive the same offset? Are funds lost or is there a recovery mechanism? (High)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::register_offset()] [Critical - Surjective Offset Mapping] The comment at lines 173-175 notes offsets are surjective not bijective - does this mean multiple logical addresses map to the same Bitcoin address, creating a mint/burn accounting vulnerability? (Critical)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::register_offset()] [High - Arbitrary Script Path] The warning at lines 177-179 about arbitrary offsets introducing script paths is critical - how does the caller ensure offsets are securely generated? What prevents a malicious processor from registering exploitable offsets? (High)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::register_offset()] [Medium - Offset Increment] At line 193, offset += Scalar::ONE could overflow if offset is already Scalar::MAX - does this wrap to zero or panic? (Medium)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::register_offset()] [High - HashMap Poisoning] If an attacker can register many offsets, can they force the HashMap to reha hash causing DoS, or can they register offsets that collide with future legitimate offsets? (High)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::register_offset()] [Critical - Registration Order Dependency] The comment at line 174-175 states 'order offsets are registered in may determine validity of future offsets' - could this create a race condition where validators register offsets in different orders and scan different addresses? (Critical)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::scan_transaction()] [High - Missing Outputs] At line 203, if vout exceeds 2^32 the scanning stops - could an attacker put a critical payment in output 2^32 + 1 to make it undetectable? (High)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::scan_transaction()] [Medium - Duplicate Detection] If the same script appears multiple times in tx.output, does scan_transaction return duplicate ReceivedOutputs with the same outpoint but different offsets? (Medium)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::scan_transaction()] [High - TxID Malleability] Line 209 uses compute_txid() - is this the witness-committed txid (wtxid) or the legacy txid, and could transaction malleability cause the same output to be seen with different outpoints? (High)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::scan_transaction()] [Critical - Script Clone] At line 208, output.clone() is called - if the output contains a large witness script, could this be a DoS vector through memory exhaustion? (Critical)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::scan_transaction()] [Low - Vec Growth] The result Vec at line 200 has no capacity hint - for a transaction with many matching outputs, could repeated allocations cause performance issues? (Low)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::scan_transaction()] [Medium - Vout Cast] The try_from at line 203 converts usize to u32 - on 64-bit systems with malicious input, could this silently truncate legitimate vout indices? (Medium)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::scan_block()] [High - Coinbase Maturity] Lines 218-220 mention scanning coinbase transactions bound by maturity - if these immature outputs are used in subsequent transactions before maturity, do they cause consensus failures? (High)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::scan_block()] [Medium - Block Scanning Order] At line 223, block.txdata is scanned in order - if a reorg occurs and transactions are reordered, could this cause outputs to be double-counted or missed? (Medium)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::scan_block()] [Critical - Vec Extend DoS] Line 224 uses extend() without bounds checking - if block contains thousands of matching outputs, could this exhaust memory? (Critical)",
  "[File: networks/bitcoin/src/wallet/mod.rs] [Function: Scanner::scan_block()] [Low - Unused Result] The result Vec from scan_transaction is immediately extended into res - could there be any race condition or state inconsistency during this operation? (Low)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [Critical - Insufficient Funds] At lines 215-221, the NotEnoughFunds check compares input_sat < (payment_sat + needed_fee), but does this account for potential integer overflow if payment_sat and needed_fee are near u64::MAX? (Critical)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [High - Fee Underestimation] The fee calculation at line 206 uses vbytes, but lines 225-234 recalculate with change - if the change output causes the transaction to cross a weight boundary, could the fee be underestimated? (High)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [Critical - Change Output Theft] At lines 228-234, if input_sat.checked_sub returns None due to underflow, no change output is created and excess funds become fee - could an attacker manipulate inputs to cause this and steal funds via miner fees? (Critical)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [High - DUST Threshold Bypass] Lines 165-169 check payments against DUST (546 sats), but line 229 checks change against DUST - could an attacker craft inputs that create change just below DUST to burn user funds? (High)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [Medium - Data Size Limit] Line 171-173 checks data.len() > 80 for OP_RETURN, but does this account for the OP_RETURN opcode bytes themselves, or could a 80-byte payload plus opcode exceed limits? (Medium)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [Critical - Empty Outputs] Line 237-239 checks if tx_outs is empty after all operations - could edge cases in change calculation cause all outputs to be removed, passing excess funds to miners? (Critical)",
  "[File: networks/bitcoin/src/wallet/send.rs] [Function: SignableTransaction::new()] [High - Transaction Size Overflow] Line 241-243 checks weight against MAX_STANDARD_TX_WEIGHT, but is this checked before or after witnesses are added, and could witness data push it over the limit? (High)"
]