[
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 134-156: Field::sqrt_ratio()] [Critical - Incorrect Ratio Root] Does sqrt_ratio(u, v) correctly compute sqrt(u/v) per RFC 8032, or could errors allow invalid Ed25519 y-coordinates to produce points not on the curve, breaking FROST verification?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 140-141: sqrt_ratio() v powers] [High - Arithmetic Error] Do v3 = v.square() * v and v7 = v3.square() * v correctly compute v^3 and v^7, or could multiplication order errors cause sqrt_ratio to return wrong values for FROST group element decompression?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Line 142: sqrt_ratio() candidate root] [High - Exponentiation Error] Does (u * v3) * (u * v7).pow(MOD_5_8) correctly compute the candidate root, or could pow() bugs cause sqrt_ratio to fail for valid inputs needed in Ed25519 operations?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 145-147: sqrt_ratio() correctness checks] [Critical - Logic Error] Do correct_sign, flipped_sign, and flipped_sign_i checks correctly detect which root adjustment is needed, or could logic errors allow sqrt_ratio to return non-roots that break Ristretto encoding?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Line 149: sqrt_ratio() conditional assignment] [High - Selection Error] Does r.conditional_assign(&(r * i), flipped_sign | flipped_sign_i) correctly multiply by sqrt(-1) when needed, or could incorrect conditions return wrong roots for Ed25519 point decoding?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 151-152: sqrt_ratio() sign normalization] [Medium - Canonicalization Error] Does r.conditional_negate(r.is_odd()) correctly ensure the even root is returned, or could sign errors cause non-canonical Ed25519 point representations in FROST?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Line 154: sqrt_ratio() return value] [Medium - Boolean Logic Error] Does (correct_sign | flipped_sign) correctly indicate success, or should it be (correct_sign | flipped_sign | flipped_sign_i) to match Ristretto's extended acceptance criteria?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 134-156: Field::sqrt_ratio()] [Low - Side-Channel] Do all operations run in constant time regardless of whether u/v is a square, or could timing leak whether an Ed25519 point is valid, potentially revealing FROST signing activity?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 190-193: PrimeField::from_repr()] [Critical - Range Check Bypass] Does res.ct_lt(&MODULUS) correctly reject bytes >= p, or could a comparison bug allow out-of-range field elements that break FROST signature verification when deserializing shares?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 190-193: PrimeField::from_repr()] [High - Endianness Error] Does U256::from_le_bytes() correctly interpret little-endian input, or could big-endian confusion cause field element corruption when deserializing FROST messages?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 190-193: PrimeField::from_repr()] [High - Constant-Time Violation] Is the ct_lt comparison truly constant-time, or could timing leak information about whether deserialized FROST shares are close to the modulus?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 190-193: PrimeField::from_repr()] [Medium - Reduction Error] Does ResidueType::new(&res) correctly reduce res modulo p even when res >= p, or could it store out-of-range values if ct_lt check is bypassed?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 194-196: PrimeField::to_repr()] [Medium - Canonicalization Error] Does self.0.retrieve().to_le_bytes() always return the canonical reduced representation, or could it return values >= p that fail to deserialize, breaking FROST message encoding?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 194-196: PrimeField::to_repr()] [Medium - Side-Channel] Does retrieve() run in constant time, or could it leak information about secret FROST shares through timing when serializing for network transmission?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 194-196: PrimeField::to_repr()] [Low - Endianness Consistency] Does to_le_bytes() match the endianness expected by from_repr(), or could endianness mismatch cause round-trip serialization failures for FROST shares?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 198-200: PrimeField::is_odd()] [High - Constant-Time Violation] Does self.0.retrieve().is_odd() run in constant time, or could timing leak the parity of secret FROST scalars, potentially revealing key bits through side-channel analysis?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 198-200: PrimeField::is_odd()] [Medium - Correctness Error] Does is_odd() check the least significant bit of the canonical representation, or could it check a non-reduced value causing incorrect parity for Ed25519 operations?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 235-270: FieldElement::pow()] [Critical - Side-Channel] Does the windowed exponentiation algorithm run in constant time, or do conditional branches and table lookups leak the exponent bits, allowing attackers to recover FROST secret keys?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 236-240: pow() table initialization] [High - Table Computation Error] Does the table computation table[i] = table[i-1] * self correctly build powers of self, or could off-by-one errors cause wrong exponentiations that break FROST key derivation?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 244-248: pow() bit extraction] [Critical - Timing Leak] Does the bit iteration and accumulation leak timing information about the exponent, potentially revealing FROST nonces or secret shares through cache timing attacks?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Line 246: pow() u8_from_bool] [Medium - Conversion Error] Does u8_from_bool correctly extract bit values, or could it introduce errors that cause pow() to compute wrong exponentiations for FROST operations?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 250-267: pow() windowing logic] [High - Window Accumulation Error] Does the 4-bit windowing with (i+1) % 4 boundary checking correctly accumulate exponent bits, or could off-by-one errors skip or duplicate bits causing wrong FROST computations?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 251-255: pow() squaring loop] [Medium - Squaring Count Error] Does the if i != 3 check correctly skip initial squaring, or could incorrect squaring counts cause pow() to compute self^(k*2^n) instead of self^k?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 257-264: pow() table lookup] [Critical - Cache Timing] Does the conditional_select loop over all 16 table entries leak which entry is selected through cache access patterns, revealing FROST exponent values?",
  "[File: serai/crypto/dalek-ff-group/src/field.rs] [Lines 257-264: pow() table lookup] [High - Selection Logic Error] Does bits.ct_eq(&(i as u8)) correctly select the right table entry, or could casting errors or off-by-one bugs cause wrong table lookups that break FROST signing?"
]