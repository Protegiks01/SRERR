[
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block_hash()] [Type Safety - Low] Does BlockHash deserialization perform sufficient validation, or can it accept malformed hash structures?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block_number()] [Hash Format Vulnerability - High] The function passes hash without reversing bytes unlike get_block_hash()—is there inconsistency in hash format expectations that can cause lookups to fail or succeed incorrectly?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block_number()] [Hex Encoding Attack - Medium] Can special characters or malformed hex in the hash cause injection vulnerabilities or parsing errors that are silently ignored?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block_number()] [Orphaned Block - High] Can this return a valid height for an orphaned block that's not in the main chain, causing consensus issues when cross-referencing with get_block_hash()?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block_number()] [Deserialization Vulnerability - Medium] The custom Number struct only extracts height field—can extra fields in the response be exploited to cause deserialization confusion?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block()] [Block Substitution - Critical] After validating block_hash matches, if a Bitcoin reorg occurs and the block is replaced, can stale block data be processed leading to mint/burn mismatches?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block()] [Deserialization Bomb - High] Can a malicious Bitcoin node return valid hex that deserializes into an extremely large Block structure (e.g., millions of transactions) causing memory exhaustion?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block()] [Hash Verification Bypass - Critical] The block hash validation uses reversed bytes—if the comparison logic has any flaw, can a wrong block be accepted as valid?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block()] [Hex Decoding Vulnerability - High] Can FromHex::from_hex fail to properly validate hex encoding, allowing partial decoding or buffer overflow conditions?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block()] [Consensus Encoding Attack - High] Does encode::deserialize perform complete Bitcoin consensus rule validation, or can non-standard blocks be deserialized that would be rejected by Bitcoin consensus?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block()] [Error Handling - Medium] If deserialization fails partway through, can partial block data remain in memory or affect subsequent calls?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block()] [Verbosity Parameter - Low] The verbosity level 0 returns raw hex—can requesting different verbosity levels cause inconsistent data formats or expose additional information?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_block()] [Timestamp Manipulation - Medium] Are block timestamps validated against expected ranges to prevent time-based attacks on finality determination?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: send_raw_transaction()] [Double-Spend Prevention - Critical] When RPC_VERIFY_ALREADY_IN_CHAIN is returned, does computing txid from the local Transaction guarantee it matches what's actually on-chain, or can a different transaction with the same ID exist?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: send_raw_transaction()] [Transaction Malleability - Critical] If the Bitcoin node accepts the transaction but returns a different txid due to malleability, the check at line 204 catches it—but can this leave the transaction in mempool without proper tracking?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: send_raw_transaction()] [Replay Attack - Critical] Does the already-in-chain check prevent cross-network replay attacks if Serai processes multiple Bitcoin-like networks with the same transaction format?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: send_raw_transaction()] [Error Code Spoofing - High] Can a malicious Bitcoin node return error code -27 for transactions that are NOT in the chain, causing Serai to believe a failed broadcast succeeded?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: send_raw_transaction()] [Mempool Acceptance - High] Does successful sendrawtransaction guarantee the transaction will be mined, or can mempool eviction cause fund loss if refunds aren't tracked?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: send_raw_transaction()] [Fee Estimation - Medium] If the transaction has insufficient fees, can it be stuck indefinitely in mempool without triggering an error?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: send_raw_transaction()] [Consensus Rules - High] Can a transaction be broadcast that violates consensus rules but is accepted by the node, later causing rejection when included in a block?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: send_raw_transaction()] [RBF Attack - High] Can Replace-By-Fee allow an attacker to replace a Serai multisig transaction with a different one after initial broadcast?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: send_raw_transaction()] [Serialization Validation - Medium] Does encode::serialize_hex properly handle all transaction types including Taproot, SegWit, and legacy formats without data loss?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_transaction()] [Transaction Substitution - Critical] The validation checks computed txid matches requested hash—but can a Bitcoin node serve a valid transaction with matching ID from a different block or chain?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_transaction()] [Mempool vs Confirmed - Critical] Does getrawtransaction distinguish between mempool and confirmed transactions? Can unconfirmed transactions be treated as finalized?",
  "[File: serai/networks/bitcoin/src/rpc.rs] [Function: get_transaction()] [Hash Endianness - High] Similar to blocks, the hash bytes are reversed before comparison—can inconsistent reversal across the codebase lead to lookup failures or wrong transactions?"
]