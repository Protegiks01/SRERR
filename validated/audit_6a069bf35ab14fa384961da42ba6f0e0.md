# Audit Report

## Title
Malicious Bitcoin Node Can Prevent Transaction Broadcast via Error Code -27 Spoofing

## Summary
The Bitcoin RPC integration unconditionally trusts error code -27 (RPC_VERIFY_ALREADY_IN_CHAIN) without verifying the transaction actually exists on-chain. A malicious Bitcoin node can exploit this by returning false -27 errors, causing validators to believe transactions were broadcast when they were not, resulting in users burning tokens without receiving corresponding Bitcoin outputs.

## Finding Description

The vulnerability exists in the `send_raw_transaction()` function's error handling logic. [1](#0-0) 

When a Bitcoin RPC returns error code -27, the code immediately returns success without any verification that the transaction actually exists in the blockchain or mempool. A malicious Bitcoin node can abuse this by returning -27 for transactions that were never broadcast to the Bitcoin network.

**Execution Flow:**

1. Validators complete FROST signing and obtain a transaction completion [2](#0-1) 

2. The completion is saved to `CompletionsDb` BEFORE publishing [3](#0-2) 

3. Each participating validator calls `publish_completion()` [4](#0-3) 

4. For Bitcoin, this invokes `send_raw_transaction()` [5](#0-4) 

5. If the RPC returns -27, the function returns `Ok()` without verification [6](#0-5) 

**Why Mitigations Fail:**

- **Scanner Detection**: The scanner independently checks for transactions on-chain [7](#0-6)  but if the transaction was never broadcast, it will never be found in any block.

- **Peer Verification**: When other validators receive completion claims, they call `confirm_completion()` [8](#0-7)  which attempts to retrieve the transaction via RPC [9](#0-8) . However, failures only produce warnings and do not trigger remediation [10](#0-9) 

- **Rebroadcast Task**: The rebroadcast mechanism continuously republishes completions [11](#0-10)  but if validators continue hitting malicious nodes, they keep receiving -27 and "succeeding" without actual broadcast.

- **Reattempt Prevention**: Reattempts are blocked because `already_completed()` returns true once `CompletionsDb` contains entries [12](#0-11)  and [13](#0-12) 

## Impact Explanation

This vulnerability violates the critical bridge invariant that "burns map to spendable external outputs". When users burn sriXYZ tokens to withdraw Bitcoin:

1. Tokens are destroyed on Serai
2. Validators sign the Bitcoin withdrawal transaction  
3. If all validators use malicious/compromised Bitcoin RPC infrastructure, the transaction is never broadcast
4. Users lose their burned tokens with no corresponding Bitcoin output
5. Funds remain locked in the multisig, creating an accounting mismatch

The severity is HIGH because it causes direct user fund loss and breaks the fundamental bridge functionality. While not explicitly listed in the severity framework's "Critical" category (which focuses on receiving funds), this represents the inverse scenario - users send funds (burn tokens) but never receive the expected external output, which is equally severe for a bridge protocol.

The attack is realistic when validators use shared Bitcoin RPC infrastructure (common in production deployments for cost efficiency), where a single compromised node affects all validators.

## Likelihood Explanation  

**Attacker Requirements:**
- Compromise or control Bitcoin RPC infrastructure used by validators
- Ability to return false error code -27 responses

**Attack Feasibility:**
The threat model explicitly designates "any RPC caller" as untrusted. A Bitcoin RPC node is an external service that falls under this category. The protocol should not unconditionally trust RPC responses without verification.

**Deployment Scenarios:**
- If validators use **diverse** Bitcoin infrastructure: At least one honest node should successfully broadcast, mitigating the attack
- If validators use **shared** infrastructure: Single point of compromise affects all validators, enabling the attack

The report indicates shared infrastructure is "common in production", making this a realistic threat vector. Even if only a subset of validators share infrastructure, those validators' users would be affected.

**Economic Incentive:**
Attackers can cause loss of withdrawal amounts, potentially combined with market manipulation (shorting sriXYZ) or exploiting liquidity pools.

## Recommendation

Modify `send_raw_transaction()` to verify the transaction actually exists when receiving error code -27:

```rust
pub async fn send_raw_transaction(&self, tx: &Transaction) -> Result<Txid, RpcError> {
  let txid = match self.rpc_call("sendrawtransaction", json!([encode::serialize_hex(tx)])).await {
    Ok(txid) => txid,
    Err(e) => {
      const RPC_VERIFY_ALREADY_IN_CHAIN: isize = -27;
      if let RpcError::RequestError(Error { code, .. }) = e {
        if code == RPC_VERIFY_ALREADY_IN_CHAIN {
          // Verify the transaction actually exists before treating as success
          match self.get_transaction(&tx.compute_txid().as_raw_hash().to_byte_array()).await {
            Ok(_) => return Ok(tx.compute_txid()),
            Err(_) => {
              // Transaction doesn't actually exist despite -27 error
              // Treat as a real error and retry
              return Err(RpcError::InvalidResponse("node returned -27 but transaction doesn't exist"));
            }
          }
        }
      }
      Err(e)?
    }
  };
  if txid != tx.compute_txid() {
    Err(RpcError::InvalidResponse("returned TX ID inequals calculated TX ID"))?;
  }
  Ok(txid)
}
```

Additionally, enhance `confirm_completion()` error handling to trigger active remediation (re-signing or alerting) rather than just logging warnings when transaction verification fails.

## Proof of Concept

A complete PoC would require:
1. Setting up a malicious Bitcoin RPC that returns -27 for specific transactions
2. Configuring validators to use this RPC
3. Initiating a withdrawal and observing that the transaction never appears on-chain despite validators reporting success

The vulnerability is evident from code inspection: error code -27 is trusted without verification, creating a false success path that can be exploited by malicious RPC infrastructure.

### Citations

**File:** networks/bitcoin/src/rpc.rs (L188-208)
```rust
  /// Publish a transaction.
  pub async fn send_raw_transaction(&self, tx: &Transaction) -> Result<Txid, RpcError> {
    let txid = match self.rpc_call("sendrawtransaction", json!([encode::serialize_hex(tx)])).await {
      Ok(txid) => txid,
      Err(e) => {
        // A const from Bitcoin's bitcoin/src/rpc/protocol.h
        const RPC_VERIFY_ALREADY_IN_CHAIN: isize = -27;
        // If this was already successfully published, consider this having succeeded
        if let RpcError::RequestError(Error { code, .. }) = e {
          if code == RPC_VERIFY_ALREADY_IN_CHAIN {
            return Ok(tx.compute_txid());
          }
        }
        Err(e)?
      }
    };
    if txid != tx.compute_txid() {
      Err(RpcError::InvalidResponse("returned TX ID inequals calculated TX ID"))?;
    }
    Ok(txid)
  }
```

**File:** processor/src/signer.rs (L190-205)
```rust
  pub async fn rebroadcast_task(db: D, network: N) {
    log::info!("rebroadcasting transactions for plans whose completions yet to be confirmed...");
    loop {
      for active in ActiveSignsDb::get(&db).unwrap_or_default() {
        for claim in CompletionsDb::completions::<N>(&db, active) {
          log::info!("rebroadcasting completion with claim {}", hex::encode(claim.as_ref()));
          // TODO: Don't drop the error entirely. Check for invariants
          let _ =
            network.publish_completion(&CompletionDb::completion::<N>(&db, &claim).unwrap()).await;
        }
      }
      // Only run every five minutes so we aren't frequently loading tens to hundreds of KB from
      // the DB
      tokio::time::sleep(core::time::Duration::from_secs(5 * 60)).await;
    }
  }
```

**File:** processor/src/signer.rs (L254-265)
```rust
  fn already_completed(txn: &mut D::Transaction<'_>, id: [u8; 32]) -> bool {
    if !CompletionsDb::completions::<N>(txn, id).is_empty() {
      debug!(
        "SignTransaction/Reattempt order for {}, which we've already completed signing",
        hex::encode(id)
      );

      true
    } else {
      false
    }
  }
```

**File:** processor/src/signer.rs (L311-362)
```rust
  async fn claimed_eventuality_completion(
    &mut self,
    txn: &mut D::Transaction<'_>,
    id: [u8; 32],
    claim: &<N::Eventuality as Eventuality>::Claim,
  ) -> Option<ProcessorMessage> {
    if let Some(eventuality) = EventualityDb::eventuality::<N>(txn, id) {
      match self.network.confirm_completion(&eventuality, claim).await {
        Ok(Some(completion)) => {
          info!(
            "signer eventuality for {} resolved in {}",
            hex::encode(id),
            hex::encode(claim.as_ref())
          );

          let first_completion = !Self::already_completed(txn, id);

          // Save this completion to the DB
          CompletionsDb::complete::<N>(txn, id, &completion);

          if first_completion {
            return Some(self.complete(id, claim));
          }
        }
        Ok(None) => {
          warn!(
            "a validator claimed {} completed {} when it did not",
            hex::encode(claim.as_ref()),
            hex::encode(id),
          );
        }
        Err(_) => {
          // Transaction hasn't hit our mempool/was dropped for a different signature
          // The latter can happen given certain latency conditions/a single malicious signer
          // In the case of a single malicious signer, they can drag multiple honest validators down
          // with them, so we unfortunately can't slash on this case
          warn!(
            "a validator claimed {} completed {} yet we couldn't check that claim",
            hex::encode(claim.as_ref()),
            hex::encode(id),
          );
        }
      }
    } else {
      warn!(
        "informed of completion {} for eventuality {}, when we didn't have that eventuality",
        hex::encode(claim.as_ref()),
        hex::encode(id),
      );
    }
    None
  }
```

**File:** processor/src/signer.rs (L467-469)
```rust
    if Self::already_completed(txn, id) {
      return None;
    }
```

**File:** processor/src/signer.rs (L602-630)
```rust
        let completion = match machine.complete(shares) {
          Ok(res) => res,
          Err(e) => match e {
            FrostError::InternalError(_) |
            FrostError::InvalidParticipant(_, _) |
            FrostError::InvalidSigningSet(_) |
            FrostError::InvalidParticipantQuantity(_, _) |
            FrostError::DuplicatedParticipant(_) |
            FrostError::MissingParticipant(_) => unreachable!(),

            FrostError::InvalidPreprocess(l) | FrostError::InvalidShare(l) => {
              return Some(ProcessorMessage::InvalidParticipant { id, participant: l })
            }
          },
        };

        // Save the completion in case it's needed for recovery
        CompletionsDb::complete::<N>(txn, id.id, &completion);

        // Publish it
        if let Err(e) = self.network.publish_completion(&completion).await {
          error!("couldn't publish completion for plan {}: {:?}", hex::encode(id.id), e);
        } else {
          info!("published completion for plan {}", hex::encode(id.id));
        }

        // Stop trying to sign for this TX
        Some(self.complete(id.id, &N::Eventuality::claim(&completion)))
      }
```

**File:** processor/src/networks/bitcoin.rs (L844-853)
```rust
  async fn publish_completion(&self, tx: &Transaction) -> Result<(), NetworkError> {
    match self.rpc.send_raw_transaction(tx).await {
      Ok(_) => (),
      Err(RpcError::ConnectionError) => Err(NetworkError::ConnectionError)?,
      // TODO: Distinguish already in pool vs double spend (other signing attempt succeeded) vs
      // invalid transaction
      Err(e) => panic!("failed to publish TX {}: {e}", tx.compute_txid()),
    }
    Ok(())
  }
```

**File:** processor/src/networks/bitcoin.rs (L855-863)
```rust
  async fn confirm_completion(
    &self,
    eventuality: &Self::Eventuality,
    _: &EmptyClaim,
  ) -> Result<Option<Transaction>, NetworkError> {
    Ok(Some(
      self.rpc.get_transaction(&eventuality.0).await.map_err(|_| NetworkError::ConnectionError)?,
    ))
  }
```

**File:** processor/src/multisigs/scanner.rs (L569-590)
```rust
          for (id, (block_number, tx, completion)) in network
            .get_eventuality_completions(scanner.eventualities.get_mut(&key_vec).unwrap(), &block)
            .await
          {
            info!(
              "eventuality {} resolved by {}, as found on chain",
              hex::encode(id),
              hex::encode(tx.as_ref())
            );

            completion_block_numbers.push(block_number);
            // This must be before the mission of ScannerEvent::Block, per commentary in mod.rs
            if !scanner.emit(ScannerEvent::Completed(
              key_vec.clone(),
              block_number,
              id,
              tx,
              completion,
            )) {
              return;
            }
          }
```
