# Audit Report

## Title
Undocumented Panic in IetfTranscript::rng_seed() Reachable Through Public API

## Summary
The `IetfTranscript::rng_seed()` method contains an `unimplemented!()` macro that causes a panic when invoked. This method is reachable through the public API via `IetfSchnorr::ietf().transcript().rng_seed()`, with no user-facing documentation warning about this limitation.

## Finding Description

The `IetfTranscript` type implements the `Transcript` trait but leaves the `rng_seed()` method unimplemented with a panic macro: [1](#0-0) 

While an internal comment at line 121 states "FROST won't use this and this shouldn't be used outside of FROST," this is not user-facing documentation. The `IetfTranscript` is accessible through the public `IetfSchnorr` type alias: [2](#0-1) 

Users can construct `IetfSchnorr` instances via the public `ietf()` constructor: [3](#0-2) 

The `Algorithm` trait exposes the `transcript()` method publicly: [4](#0-3) 

The `Transcript` trait defines `rng_seed()` as a public method with documented legitimate use cases: [5](#0-4) 

**Call Path**: `IetfSchnorr::ietf()` → `.transcript()` → `.rng_seed(label)` → panic

The `rng_seed()` method is a standard part of the `Transcript` trait interface, documented as a "Helper function for parties needing to generate random data from an agreed upon state." Other implementations like `DigestTranscript` properly implement this method: [6](#0-5) 

The standard transcript test suite explicitly tests `rng_seed()` functionality: [7](#0-6) 

However, `IetfTranscript` is not tested with this suite, leaving the panic undiscovered.

## Impact Explanation

This is classified as **Low severity** per the audit scope's explicit inclusion of "Undocumented panic reachable from a public API."

**Concrete Impact:**
- Thread or process crash when `rng_seed()` is invoked
- Local denial of service for the calling application
- No cryptographic security compromise
- No secret leakage
- No impact on other FROST protocol participants

The impact is limited to application availability and does not affect the security guarantees of the FROST threshold signature protocol itself.

## Likelihood Explanation

**Likelihood: Very Low**

While technically reachable via straightforward API calls, the realistic likelihood is very low because:

1. Normal FROST usage patterns pass the algorithm directly to signing machinery without accessing the transcript
2. The FROST internal implementation never calls `rng_seed()` on `IetfTranscript`
3. Users have no documented reason to call `rng_seed()` on a signing algorithm's transcript

However, the method remains part of the public API with documented use cases in the `Transcript` trait, making it a valid API surface that users might reasonably attempt to use.

## Recommendation

**Option 1: Implement the method**
```rust
fn rng_seed(&mut self, label: &'static [u8]) -> [u8; 32] {
    let mut seed = [0; 32];
    let challenge = self.challenge(label);
    seed.copy_from_slice(&challenge[..32.min(challenge.len())]);
    seed
}
```

**Option 2: Document the limitation**
Add clear documentation to `IetfSchnorr` and `IetfTranscript` warning that `rng_seed()` is not supported and will panic if called.

**Option 3: Use a different transcript type**
The codebase already provides `RecommendedTranscript` with full `Transcript` trait support. Consider making this the default recommendation for most use cases, reserving `IetfSchnorr` strictly for IETF compatibility testing.

## Proof of Concept

```rust
use modular_frost::{curve::Secp256k1, algorithm::IetfSchnorr, Algorithm};
use transcript::Transcript;

#[test]
#[should_panic(expected = "not implemented")]
fn test_ietf_transcript_rng_seed_panic() {
    // Create an IetfSchnorr algorithm instance
    let mut algo = IetfSchnorr::<Secp256k1, _>::ietf();
    
    // Access the transcript through the public API
    let transcript = algo.transcript();
    
    // Attempt to use rng_seed - this will panic
    let _seed = transcript.rng_seed(b"test");
}
```

This test demonstrates that calling `rng_seed()` on an `IetfSchnorr` algorithm's transcript triggers the unimplemented panic through normal public API usage.

### Citations

**File:** crypto/frost/src/algorithm.rs (L28-38)
```rust
pub trait Algorithm<C: Curve>: Send + Sync {
  /// The transcript format this algorithm uses. This likely should NOT be the IETF-compatible
  /// transcript included in this crate.
  type Transcript: Sync + Clone + Debug + Transcript;
  /// Serializable addendum, used in algorithms requiring more data than just the nonces.
  type Addendum: Addendum;
  /// The resulting type of the signatures this algorithm will produce.
  type Signature: Clone + PartialEq + Debug;

  /// Obtain a mutable borrow of the underlying transcript.
  fn transcript(&mut self) -> &mut Self::Transcript;
```

**File:** crypto/frost/src/algorithm.rs (L122-124)
```rust
    fn rng_seed(&mut self, _: &'static [u8]) -> [u8; 32] {
      unimplemented!()
    }
```

**File:** crypto/frost/src/algorithm.rs (L155-155)
```rust
pub type IetfSchnorr<C, H> = Schnorr<C, IetfTranscript, H>;
```

**File:** crypto/frost/src/algorithm.rs (L168-170)
```rust
  pub fn ietf() -> IetfSchnorr<C, H> {
    Schnorr::new(IetfTranscript(vec![]))
  }
```

**File:** crypto/transcript/src/lib.rs (L46-53)
```rust
  /// Produce a RNG seed.
  ///
  /// Helper function for parties needing to generate random data from an agreed upon state.
  ///
  /// Implementors MAY internally call the challenge function for the needed bytes, and accordingly
  /// produce a transcript conflict between two transcripts, one which called challenge(label) and
  /// one which called rng_seed(label) at the same point.
  fn rng_seed(&mut self, label: &'static [u8]) -> [u8; 32];
```

**File:** crypto/transcript/src/lib.rs (L136-140)
```rust
  fn rng_seed(&mut self, label: &'static [u8]) -> [u8; 32] {
    let mut seed = [0; 32];
    seed.copy_from_slice(&self.challenge(label)[.. 32]);
    seed
  }
```

**File:** crypto/transcript/src/tests.rs (L74-83)
```rust
  // Ensure RNG seed calls advance the transcript
  {
    let mut t = t();
    let s1 = t.rng_seed(b"s");
    let s2 = t.rng_seed(b"s");
    assert!(s1 != s2);
  }

  // Ensure distinct RNG seed labels produce distinct seeds
  assert!(t().rng_seed(b"a") != t().rng_seed(b"b"));
```
