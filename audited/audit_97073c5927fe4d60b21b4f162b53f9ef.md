### Title
Undocumented Panic on Unknown Bitcoin RPC Error Codes in Transaction Publishing

### Summary
The `publish_completion` method in the Bitcoin network implementation panics for any RPC error except `ConnectionError`, including unknown or unexpected error codes returned by Bitcoin nodes. This causes the processor to crash during normal operations when Bitcoin nodes return legitimate error codes such as transaction-already-in-mempool or verification-failure, halting all transaction processing for the validator until manual restart.

### Finding Description

**Location**: [1](#0-0) 

The `publish_completion` method only handles `ConnectionError` explicitly and panics for all other RPC error types. [2](#0-1) 

**Root Cause**: The Bitcoin RPC can return various error codes beyond the special-cased `-27` (RPC_VERIFY_ALREADY_IN_CHAIN) that is handled in `send_raw_transaction`. [3](#0-2) 

When `send_raw_transaction` returns errors like `RpcError::RequestError` with other error codes, `RpcError::InvalidJson`, `RpcError::InvalidResponse`, or `RpcError::MissingMethods`, the panic is triggered.

**Why Existing Mitigations Fail**: Error handling exists at the call sites [4](#0-3)  and in the rebroadcast task, [5](#0-4)  but these handlers are bypassed because the panic occurs before an error can be returned.

The TODO comment acknowledges multiple legitimate error scenarios but lacks implementation. [6](#0-5) 

### Impact Explanation

**Affected Party**: Validators running the processor component.

**Specific Harm**: When a Bitcoin node returns any non-ConnectionError RPC response (transaction already in mempool, verification failure, invalid transaction, deserialization error, etc.), the processor immediately crashes with a panic. This halts:
- All transaction signing and publishing operations
- The rebroadcast task that ensures completion propagation
- All processor functionality for that validator

**Severity Justification**: Low severity per protocol scope definition: "Undocumented panic reachable from a public API." The panic disrupts validator operations and network availability but does not directly cause loss of funds or compromise cryptographic security.

### Likelihood Explanation

**Required Capabilities**: None beyond normal validator operation. The panic is triggered by standard Bitcoin node responses during transaction publishing.

**Attack Complexity**: No attack required. Normal operational scenarios trigger this:
- Transaction already exists in mempool (different error code than -27)
- Transaction fails validation checks
- Network policy rejection (e.g., insufficient fee)
- Node mempool is full
- RPC response format issues

**Economic Feasibility**: N/A - this is an availability issue triggered by normal operations, not an economic attack.

**Detection Risk**: Immediate - the process crash is obvious and requires manual intervention to restart.

### Recommendation

Replace the panic with proper error propagation:

```rust
async fn publish_completion(&self, tx: &Transaction) -> Result<(), NetworkError> {
  match self.rpc.send_raw_transaction(tx).await {
    Ok(_) => Ok(()),
    Err(RpcError::ConnectionError) => Err(NetworkError::ConnectionError),
    // Handle specific error codes if needed
    Err(RpcError::RequestError(Error { code, message })) => {
      log::warn!("Bitcoin RPC error publishing TX {}: code={}, message={}", 
                 tx.compute_txid(), code, message);
      // Return error instead of panicking to allow retry/recovery
      Err(NetworkError::ConnectionError) // or create a new NetworkError variant
    }
    Err(e) => {
      log::error!("Unexpected error publishing TX {}: {}", tx.compute_txid(), e);
      Err(NetworkError::ConnectionError) // or create a new NetworkError variant
    }
  }
}
```

Alternative: Add a new `NetworkError` variant for publishable but rejected transactions to distinguish from transient connection issues.

**Testing**: Verify error handling with mock Bitcoin RPC returning various error codes (-25, -26, etc.) and confirm processor continues operating.

### Proof of Concept

**Exploitation Steps**:
1. Validator processor attempts to publish a transaction via `publish_completion`
2. Bitcoin node returns error code -26 (RPC_VERIFY_REJECTED) or any non-ConnectionError
3. `send_raw_transaction` returns `RpcError::RequestError(Error { code: -26, ... })`
4. Line 850 matches `Err(e)` and executes `panic!("failed to publish TX...")`
5. Processor crashes immediately

**Realistic Parameters**: 
- Error code -26: Transaction rejected by network rules
- Error code -25: Generic verification error
- Any Bitcoin Core RPC error except -27

**Expected vs Actual Behavior**:
- Expected: Error logged, transaction marked for retry or escalation, processor continues
- Actual: Processor panics and terminates, requiring manual restart

### Citations

**File:** processor/src/networks/bitcoin.rs (L844-853)
```rust
  async fn publish_completion(&self, tx: &Transaction) -> Result<(), NetworkError> {
    match self.rpc.send_raw_transaction(tx).await {
      Ok(_) => (),
      Err(RpcError::ConnectionError) => Err(NetworkError::ConnectionError)?,
      // TODO: Distinguish already in pool vs double spend (other signing attempt succeeded) vs
      // invalid transaction
      Err(e) => panic!("failed to publish TX {}: {e}", tx.compute_txid()),
    }
    Ok(())
  }
```

**File:** networks/bitcoin/src/rpc.rs (L194-199)
```rust
        const RPC_VERIFY_ALREADY_IN_CHAIN: isize = -27;
        // If this was already successfully published, consider this having succeeded
        if let RpcError::RequestError(Error { code, .. }) = e {
          if code == RPC_VERIFY_ALREADY_IN_CHAIN {
            return Ok(tx.compute_txid());
          }
```

**File:** processor/src/signer.rs (L196-198)
```rust
          // TODO: Don't drop the error entirely. Check for invariants
          let _ =
            network.publish_completion(&CompletionDb::completion::<N>(&db, &claim).unwrap()).await;
```

**File:** processor/src/signer.rs (L622-626)
```rust
        if let Err(e) = self.network.publish_completion(&completion).await {
          error!("couldn't publish completion for plan {}: {:?}", hex::encode(id.id), e);
        } else {
          info!("published completion for plan {}", hex::encode(id.id));
        }
```
