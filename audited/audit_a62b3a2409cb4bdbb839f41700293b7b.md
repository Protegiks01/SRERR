### Title
Index Out-of-Bounds Panic in BindingFactor::nonces() Due to Unvalidated Commitment Structure

### Summary
The `BindingFactor::nonces()` function performs unchecked array indexing that can panic if participants use different algorithm configurations. When commitments are deserialized with a different nonce structure than what was used during creation, subsequent indexing operations will access out-of-bounds indices, causing a panic and denial-of-service.

### Finding Description

**Code Location:** [1](#0-0) 

**Root Cause:**
The `nonces()` function assumes all stored commitments in `self.0` have the same structure as the `planned_nonces` parameter, specifically accessing `commitments.nonces[n].generators[g]` without bounds validation: [2](#0-1) 

However, when commitments are deserialized via `Commitments::read()`, they are structured according to the reader's algorithm configuration: [3](#0-2) [4](#0-3) 

If participants use different algorithm configurations (returning different structures from `Algorithm::nonces()`), the deserialized commitments will have a different structure than what `nonces()` expects, causing index out-of-bounds panics.

**Why Existing Mitigations Fail:**
There is no validation ensuring all participants use identical algorithm configurations. The serialization format contains no structure metadata: [5](#0-4) 

This allows deserialization to succeed but produce incorrectly structured commitments.

### Impact Explanation

**Affected Parties:** Any participant in a FROST signing session where other participants use different algorithm configurations.

**Concrete Impact:** Denial-of-service via panic during the signing process. When `BindingFactor::nonces()` is called with mismatched structures, array indexing panics immediately, aborting the signing session. [6](#0-5) 

**Severity Justification:** This is a Low severity finding per the audit criteria: "Undocumented panic reachable from a public API." The `SignMachine::sign()` method is part of the public API and can be triggered by providing preprocesses with incompatible structures.

### Likelihood Explanation

**Attack Prerequisites:**
- Attacker must be a participant in the signing protocol
- Attacker creates preprocesses with an algorithm configuration that returns a different structure from `Algorithm::nonces()` than honest participants use

**Attack Complexity:** Low. The attacker simply needs to:
1. Instantiate their algorithm with a different `nonces()` implementation
2. Generate and broadcast preprocesses
3. Wait for honest participants to deserialize and attempt signing

**Economic Feasibility:** No cost beyond normal participation. The attack causes immediate panic with no computational expense.

**Detection Risk:** High - the panic occurs immediately during signing, making the attack obvious. However, identifying which participant sent malformed preprocesses requires additional logging.

### Recommendation

**Primary Fix:** Add structure validation before indexing. In `BindingFactor::nonces()`, verify that all stored commitments match the expected structure:

```rust
pub(crate) fn nonces(&self, planned_nonces: &[Vec<C::G>]) -> Vec<Vec<C::G>> {
  // Validate all commitments have the expected structure
  for binding in self.0.values() {
    if binding.commitments.nonces.len() != planned_nonces.len() {
      panic!("Commitment structure mismatch: expected {} nonces, got {}", 
             planned_nonces.len(), binding.commitments.nonces.len());
    }
    for (n, planned) in planned_nonces.iter().enumerate() {
      if binding.commitments.nonces[n].generators.len() != planned.len() {
        panic!("Commitment structure mismatch at nonce {}: expected {} generators, got {}",
               n, planned.len(), binding.commitments.nonces[n].generators.len());
      }
    }
  }
  // ... existing code ...
}
```

**Alternative Mitigation:** Document in `Algorithm::nonces()` that all participants MUST use algorithms returning identical structures: [7](#0-6) 

**Testing Recommendations:** Add test cases in `crypto/frost/src/tests/nonces.rs` that verify panics occur with helpful error messages when structure mismatches are detected.

### Proof of Concept

**Exploitation Steps:**

1. **Honest participant (B) uses algorithm with structure:** `[[G]]` (1 nonce, 1 generator)
   
2. **Malicious participant (A) uses algorithm with structure:** `[[G1, G2], [G3]]` (2 nonces, 2 and 1 generators respectively)

3. **A creates and serializes preprocess:**
   - Creates commitments with 2 nonces
   - Nonce 0 has 2 generators: writes 4 group elements (D0, E0, D1, E1)
   - Nonce 1 has 1 generator: writes 2 group elements (D2, E2)
   - Total serialized: 6 group elements

4. **B deserializes using its algorithm structure `[[G]]`:**
   - Calls `Commitments::read(reader, &[[G]])`
   - Reads 1 nonce with 1 generator: reads 2 group elements (gets A's D0, E0)
   - Creates: `Commitments { nonces: [NonceCommitments { generators: [GeneratorCommitments([D0, E0])] }] }`
   - Remaining 4 group elements unread in stream

5. **B enters signing with its algorithm structure `[[G1, G2], [G3]]`:**
   - Calls `B.nonces(&[[G1, G2], [G3]])`
   - Outer loop: `for n in 0..2`
   - First iteration (n=0): `for g in 0..2`
     - g=0: accesses `commitments.nonces[0].generators[0]` ✓ exists
     - g=1: accesses `commitments.nonces[0].generators[1]` ✗ **PANIC** - index out of bounds

**Expected Behavior:** Signing proceeds normally with consistent structures.

**Actual Behavior:** Thread panics with "index out of bounds" error at line 204 or 206 of `crypto/frost/src/nonce.rs`.

### Citations

**File:** crypto/frost/src/nonce.rs (L82-87)
```rust
  fn write<W: Write>(&self, writer: &mut W) -> io::Result<()> {
    for generator in &self.generators {
      generator.write(writer)?;
    }
    Ok(())
  }
```

**File:** crypto/frost/src/nonce.rs (L133-139)
```rust
  pub(crate) fn read<R: Read>(reader: &mut R, generators: &[Vec<C::G>]) -> io::Result<Self> {
    let nonces = (0 .. generators.len())
      .map(|i| NonceCommitments::read(reader, &generators[i]))
      .collect::<Result<Vec<NonceCommitments<C>>, _>>()?;

    Ok(Commitments { nonces })
  }
```

**File:** crypto/frost/src/nonce.rs (L194-212)
```rust
  pub(crate) fn nonces(&self, planned_nonces: &[Vec<C::G>]) -> Vec<Vec<C::G>> {
    let mut nonces = Vec::with_capacity(planned_nonces.len());
    for n in 0 .. planned_nonces.len() {
      nonces.push(Vec::with_capacity(planned_nonces[n].len()));
      for g in 0 .. planned_nonces[n].len() {
        #[allow(non_snake_case)]
        let mut D = C::G::identity();
        let mut statements = Vec::with_capacity(self.0.len());
        #[allow(non_snake_case)]
        for IndividualBinding { commitments, binding_factors } in self.0.values() {
          D += commitments.nonces[n].generators[g].0[0];
          statements
            .push((binding_factors.as_ref().unwrap()[n], commitments.nonces[n].generators[g].0[1]));
        }
        nonces[n].push(D + multiexp_vartime(&statements));
      }
    }
    nonces
  }
```

**File:** crypto/frost/src/sign.rs (L276-280)
```rust
  fn read_preprocess<R: Read>(&self, reader: &mut R) -> io::Result<Self::Preprocess> {
    Ok(Preprocess {
      commitments: Commitments::read::<_>(reader, &self.params.algorithm.nonces())?,
      addendum: self.params.algorithm.read_addendum(reader)?,
    })
```

**File:** crypto/frost/src/sign.rs (L383-383)
```rust
    let Rs = B.nonces(&nonces);
```

**File:** crypto/frost/src/algorithm.rs (L40-49)
```rust
  /// Obtain the list of nonces to generate, as specified by the generators to create commitments
  /// against per-nonce.
  ///
  /// The Algorithm is responsible for all transcripting of these nonce specifications/generators.
  ///
  /// The prover will be passed the commitments, and the commitments will be sent to all other
  /// participants. No guarantees the commitments are internally consistent (have the same discrete
  /// logarithm across generators) are made. Any Algorithm which specifies multiple generators for
  /// a single nonce must handle that itself.
  fn nonces(&self) -> Vec<Vec<C::G>>;
```
