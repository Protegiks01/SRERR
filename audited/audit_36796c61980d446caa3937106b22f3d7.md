### Title
Missing Identity Element Validation Enables Free-Riding Participants and Threshold Weakening

### Summary
The FROST signature verification lacks explicit checks for zero shares and identity verification shares, allowing a malicious participant to free-ride by submitting all-zero commitments during DKG and zero shares during signing. This effectively reduces the threshold from t to t-1 participants, violating the critical threshold correctness invariant.

### Finding Description

The vulnerability spans two phases of the FROST protocol:

**Phase 1: DKG (Distributed Key Generation)**
The PedPoP DKG implementation validates commitments using Schnorr Proof-of-Knowledge but does not check that commitments are non-identity elements. [1](#0-0) 

The Schnorr PoK verification accepts the identity element because a proof with private key 0 and public key 0 (identity) is mathematically valid: [2](#0-1) 

When a participant submits all-zero commitments `C_j = 0`, the share verification equation `share * G = sum(C_j * i^j)` evaluates to `0 * G = 0`, which passes: [3](#0-2) 

This results in a zero verification share for the malicious participant.

**Phase 2: FROST Signing**
The `verify_share()` function delegates to the Schnorr implementation without checking for zero shares: [4](#0-3) [5](#0-4) 

The verification equation `s * G = R + c * A` is computed using batch statements: [6](#0-5) 

When verification share `A = 0` (identity), the equation becomes `s * G = R`, allowing a zero share `s = 0` to verify if `R = 0`, which the attacker achieves by submitting zero nonce commitments.

### Impact Explanation

**Specific Harm**: The threshold signature security is reduced from t participants to effectively t-1 participants. For a system with threshold t = ⌊2n/3⌋ + 1, this means:
- Expected security: requires t malicious participants to forge signatures
- Actual security: requires only t-1 malicious participants (when combined with one free-rider)

**Affected Parties**: All users relying on the multisig's security guarantee, including:
- External asset deposits (Bitcoin, Ethereum, Monero)
- Cross-chain transfer security
- DEX liquidity pool safety

**Quantified Impact**: If n=10 validators with t=7 threshold, one free-rider reduces effective threshold to 6, requiring only 60% collusion instead of 70% to compromise the multisig.

**Severity Justification**: Medium severity as specified - violates Critical Invariant #1 (threshold correctness) but does not completely break the system. The attack weakens but does not eliminate the threshold security property.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Control of at least one validator node
- Ability to participate in DKG
- No special cryptographic capabilities needed

**Attack Complexity**: Low
- DKG phase: Submit all-zero commitments with valid Schnorr PoK using private key 0
- Signing phase: Always submit zero nonce commitments and zero shares
- No adaptive attacks or timing exploits required
- No coordination with other malicious participants needed

**Economic Feasibility**: High
- No additional cost beyond normal validator operation
- Attack is undetectable until threshold reduction is exploited
- Can free-ride indefinitely across all signing sessions

**Detection Risk**: Low
- Zero shares appear mathematically valid
- No existing validation checks would flag this behavior
- Would only be detected if someone manually audits commitment values or notices threshold weakening during an attempted attack

### Recommendation

**Primary Fix**: Add explicit validation during DKG and signing:

1. **DKG Phase** - In `SecretShareMachine::verify_r1()`, add identity element check:
   ```
   After line 327, before inserting commitments:
   - Verify msg.commitments[0] is not the identity element
   - Reject if any commitment is identity
   ```

2. **Signing Phase** - In `Schnorr::verify_share()`, add zero share check:
   ```
   At line 224, before creating batch statements:
   - Check if share.is_zero()
   - Return Err(()) if share is zero
   ```

3. **Additional DKG Validation** - In `ThresholdKeys::new()`, verify verification shares:
   ```
   At line 365, after participant validation:
   - Check each verification_share is not identity
   - Reject keys if any verification share is identity
   ```

**Alternative Mitigation**: Implement a proof-of-secret-share protocol during DKG that cryptographically binds the commitment to a non-zero secret.

**Testing Recommendations**:
- Unit test: Attempt DKG with all-zero commitments, verify rejection
- Unit test: Attempt signing with zero share, verify rejection
- Integration test: Full DKG-to-signing flow with attempted free-riding
- Fuzz test: Random commitment values including identity and zero scalars

### Proof of Concept

**DKG Phase Exploitation**:
1. Generate commitments: `C_0 = C_1 = ... = C_{t-1} = 0` (identity element)
2. Create Schnorr PoK with private key `x = 0`:
   - Choose random nonce `r`
   - Compute `R = r * G`
   - Compute challenge `c = H(G, R, 0)`
   - Compute signature `s = c * 0 + r = r`
   - Verification: `s * G = r * G = R = R + c * 0` ✓
3. Send zero shares to all participants (field element 0)
4. Share verification by recipients: `0 * G = sum(0 * i^j) = 0` ✓
5. Result: Attacker's verification share `A_i = 0`, secret share `a_i = 0`

**Signing Phase Exploitation**:
1. Submit nonce commitments: `D_i = 0, E_i = 0` (identity elements)
2. Bound nonce computed by protocol: `R_i = 0 + 0 * rho_i = 0`
3. Submit signature share: `s_i = 0` (field element 0)
4. Verification executed by protocol:
   - Equation: `0 * G = 0 + c * lambda_i * 0 = 0` ✓ passes
5. Signature completes with t-1 honest participants' contributions
6. Attacker successfully free-rides without contributing to signature security

**Expected vs Actual Behavior**:
- Expected: All t participants contribute secret key material to signature
- Actual: Attacker contributes nothing, reducing effective threshold to t-1

### Citations

**File:** crypto/dkg/pedpop/src/lib.rs (L297-338)
```rust
impl<C: Ciphersuite> SecretShareMachine<C> {
  /// Verify the data from the previous round (canonicity, PoKs, message authenticity)
  #[allow(clippy::type_complexity)]
  fn verify_r1<R: RngCore + CryptoRng>(
    &mut self,
    rng: &mut R,
    mut commitment_msgs: HashMap<Participant, EncryptionKeyMessage<C, Commitments<C>>>,
  ) -> Result<HashMap<Participant, Vec<C::G>>, PedPoPError<C>> {
    validate_map(
      &commitment_msgs,
      &self.params.all_participant_indexes().collect::<Vec<_>>(),
      self.params.i(),
    )?;

    let mut batch = BatchVerifier::<Participant, C::G>::new(commitment_msgs.len());
    let mut commitments = HashMap::new();
    for l in self.params.all_participant_indexes() {
      let Some(msg) = commitment_msgs.remove(&l) else { continue };
      let mut msg = self.encryption.register(l, msg);

      if msg.commitments.len() != self.params.t().into() {
        Err(PedPoPError::InvalidCommitments(l))?;
      }

      // Step 5: Validate each proof of knowledge
      // This is solely the prep step for the latter batch verification
      msg.sig.batch_verify(
        rng,
        &mut batch,
        l,
        msg.commitments[0],
        challenge::<C>(self.context, l, msg.sig.R.to_bytes().as_ref(), &msg.cached_msg),
      );

      commitments.insert(l, msg.commitments.drain(..).collect::<Vec<_>>());
    }

    batch.verify_vartime_with_vartime_blame().map_err(PedPoPError::InvalidCommitments)?;

    commitments.insert(self.params.i(), self.our_commitments.drain(..).collect());
    Ok(commitments)
  }
```

**File:** crypto/dkg/pedpop/src/lib.rs (L430-449)
```rust
fn share_verification_statements<C: Ciphersuite>(
  target: Participant,
  commitments: &[C::G],
  mut share: Zeroizing<C::F>,
) -> Vec<(C::F, C::G)> {
  // This can be insecurely linearized from n * t to just n using the below sums for a given
  // stripe. Doing so uses naive addition which is subject to malleability. The only way to
  // ensure that malleability isn't present is to use this n * t algorithm, which runs
  // per sender and not as an aggregate of all senders, which also enables blame
  let mut values = exponential::<C>(target, commitments);

  // Perform the share multiplication outside of the multiexp to minimize stack copying
  // While the multiexp BatchVerifier does zeroize its flattened multiexp, and itself, it still
  // converts whatever we give to an iterator and then builds a Vec internally, welcoming copies
  let neg_share_pub = C::generator() * -*share;
  share.zeroize();
  values.push((C::F::ONE, neg_share_pub));

  values
}
```

**File:** crypto/dleq/src/cross_group/schnorr.rs (L59-76)
```rust
  pub(crate) fn verify<R: RngCore + CryptoRng, T: Transcript>(
    &self,
    rng: &mut R,
    transcript: &mut T,
    generator: G,
    public_key: G,
    batch: &mut BatchVerifier<(), G>,
  ) {
    batch.queue(
      rng,
      (),
      [
        (-self.s, generator),
        (G::Scalar::ONE, self.R),
        (Self::hra(transcript, generator, self.R, public_key), public_key),
      ],
    );
  }
```

**File:** crypto/schnorrkel/src/lib.rs (L148-155)
```rust
  fn verify_share(
    &self,
    verification_share: RistrettoPoint,
    nonces: &[Vec<RistrettoPoint>],
    share: Scalar,
  ) -> Result<Vec<(Scalar, RistrettoPoint)>, ()> {
    self.schnorr.verify_share(verification_share, nonces, share)
  }
```

**File:** crypto/frost/src/algorithm.rs (L219-230)
```rust
  fn verify_share(
    &self,
    verification_share: C::G,
    nonces: &[Vec<C::G>],
    share: C::F,
  ) -> Result<Vec<(C::F, C::G)>, ()> {
    Ok(
      SchnorrSignature::<C> { R: nonces[0][0], s: share }
        .batch_statements(verification_share, self.c.unwrap())
        .to_vec(),
    )
  }
```

**File:** crypto/schnorr/src/lib.rs (L88-100)
```rust
  pub fn batch_statements(&self, public_key: C::G, challenge: C::F) -> [(C::F, C::G); 3] {
    // s = r + ca
    // sG == R + cA
    // R + cA - sG == 0
    [
      // R
      (C::F::ONE, self.R),
      // cA
      (challenge, public_key),
      // -sG
      (-self.s, C::generator()),
    ]
  }
```
