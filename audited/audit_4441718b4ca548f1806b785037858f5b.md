### Title
Undocumented Panic in Bitcoin RPC Request Building with Malformed URLs

### Summary
The `rpc_call()` function in the Bitcoin RPC client uses `.unwrap()` when building HTTP requests, which can panic if provided with a malformed URL. This panic is undocumented and reachable through the public API `Rpc::new()`, causing application termination instead of returning a proper error when given an invalid RPC URL during initialization.

### Finding Description

The vulnerability is located in `networks/bitcoin/src/rpc.rs` in the `rpc_call()` function at lines 110-118. [1](#0-0) 

The root cause is the use of `.unwrap()` on line 118 when calling `.body()` on the hyper request builder. When `hyper::Request::post(&self.url)` is provided with a malformed URL (e.g., containing unencoded spaces, control characters, or violating RFC 3986 URI format), the builder enters an error state. The subsequent call to `.body()` returns an `Err(http::Error)`, and the `.unwrap()` causes a panic instead of returning an `RpcError`.

The URL is stored without validation during construction. [2](#0-1) 

The `Rpc::new()` function immediately calls `rpc_call()` for validation, meaning a malformed URL causes a panic during initialization rather than returning an error. The codebase has an `Error::InvalidUri` variant available [3](#0-2)  but it is not used in this code path.

Both `Rpc::new()` and `Rpc::rpc_call()` are public APIs that return `Result` types, but neither documents the possibility of panics in their signatures. [4](#0-3) [5](#0-4) 

### Impact Explanation

The impact is application-level denial of service through panic. When a malformed URL is provided to `Rpc::new()`, the application terminates with a panic instead of gracefully handling the error and returning an `RpcError::InvalidUri` or similar error type.

This affects any code that constructs an `Rpc` instance with configuration-derived URLs. While validator software should have well-formed configuration, malformed configuration files, file corruption, or deployment errors could trigger this panic, causing the entire application to crash rather than failing gracefully with a clear error message.

The severity is Low according to the audit scope criteria for "Undocumented panic reachable from a public API."

### Likelihood Explanation

The likelihood is low because:
- The URL is typically sourced from configuration files, not runtime user input
- Malformed URLs would need to bypass any external configuration validation
- An attacker would need configuration-level access, at which point they have more direct attack vectors
- The panic occurs at initialization time, making it immediately detectable during deployment

However, legitimate scenarios exist where this could occur:
- Configuration file corruption or encoding issues
- Manual configuration errors during deployment
- Automated configuration generation with bugs
- Migration issues when updating configuration formats

The attack complexity is low (simply provide an invalid URL), but the prerequisite of controlling the configuration makes practical exploitation unlikely in production environments with proper deployment procedures.

### Recommendation

Replace the `.unwrap()` calls with proper error handling that maps to `RpcError` variants:

1. Add a new `RpcError` variant for invalid URLs:
```rust
#[error("invalid RPC URL")]
InvalidUrl,
```

2. Replace the unwrapped `.body()` call with proper error handling:
```rust
let request = Request::from(
  hyper::Request::post(&self.url)
    .header("Content-Type", "application/json")
    .body(
      serde_json::to_vec(&json!({ "jsonrpc": "2.0", "method": method, "params": params }))
        .map_err(|_| RpcError::InvalidUrl)?
        .into(),
    )
    .map_err(|_| RpcError::InvalidUrl)?,
);
```

3. Consider validating the URL during `Rpc::new()` before storing it, similar to how `Client::without_connection_pool()` validates URIs. [6](#0-5) 

4. Add integration tests with malformed URLs to verify graceful error handling.

### Proof of Concept

```rust
// This will panic instead of returning an error
let url = "http://localhost:8332 with spaces".to_string();
let rpc = Rpc::new(url).await; // PANIC: invalid URI

// Another example with control characters
let url = "http://localhost:8332\n".to_string();
let rpc = Rpc::new(url).await; // PANIC: invalid URI

// Expected behavior: should return Err(RpcError::InvalidUrl)
```

The panic occurs because:
1. `hyper::Request::post("http://localhost:8332 with spaces")` creates a builder with an invalid URI
2. The builder stores the error internally
3. `.body(...)` checks the builder's error state and returns `Err(http::Error)`
4. `.unwrap()` on line 118 panics with the http::Error

The same issue exists in other parts of the codebase: [7](#0-6)  and [8](#0-7)

### Citations

**File:** networks/bitcoin/src/rpc.rs (L64-68)
```rust
  pub async fn new(url: String) -> Result<Rpc, RpcError> {
    let rpc = Rpc { client: Client::with_connection_pool(), url };

    // Make an RPC request to verify the node is reachable and sane
    let res: String = rpc.rpc_call("help", json!([])).await?;
```

**File:** networks/bitcoin/src/rpc.rs (L105-109)
```rust
  pub async fn rpc_call<Response: DeserializeOwned + Debug>(
    &self,
    method: &str,
    params: serde_json::Value,
  ) -> Result<Response, RpcError> {
```

**File:** networks/bitcoin/src/rpc.rs (L110-119)
```rust
    let mut request = Request::from(
      hyper::Request::post(&self.url)
        .header("Content-Type", "application/json")
        .body(
          serde_json::to_vec(&json!({ "jsonrpc": "2.0", "method": method, "params": params }))
            .unwrap()
            .into(),
        )
        .unwrap(),
    );
```

**File:** common/request/src/lib.rs (L24-32)
```rust
#[derive(Debug)]
pub enum Error {
  InvalidUri,
  MissingHost,
  InconsistentHost,
  ConnectionError(Box<dyn Send + Sync + std::error::Error>),
  Hyper(hyper::Error),
  HyperUtil(hyper_util::client::legacy::Error),
}
```

**File:** common/request/src/lib.rs (L82-95)
```rust
  pub fn without_connection_pool(host: &str) -> Result<Client, Error> {
    Ok(Client {
      connection: Connection::Connection {
        connector: Self::connector(),
        host: {
          let uri: Uri = host.parse().map_err(|_| Error::InvalidUri)?;
          if uri.host().is_none() {
            Err(Error::MissingHost)?;
          };
          uri
        },
        connection: Arc::new(Mutex::new(None)),
      },
    })
```

**File:** substrate/client/src/serai/mod.rs (L95-106)
```rust
    let request = Request::from(
      hyper::Request::post(&self.url)
        .header("Content-Type", "application/json")
        .body(
          serde_json::to_vec(
            &serde_json::json!({ "jsonrpc": "2.0", "id": 1, "method": method, "params": params }),
          )
          .unwrap()
          .into(),
        )
        .unwrap(),
    );
```

**File:** networks/ethereum/alloy-simple-request-transport/src/lib.rs (L41-46)
```rust
      let request = Request::from(
        hyper::Request::post(&inner.url)
          .header("Content-Type", "application/json")
          .body(serde_json::to_vec(&packet).map_err(TransportError::SerError)?.into())
          .unwrap(),
      );
```
