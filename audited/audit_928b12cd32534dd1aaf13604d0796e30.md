### Title
Undocumented Panic from Inconsistent Nonce Count in Algorithm Implementations

### Summary
The FROST signing implementation does not validate that `Algorithm::nonces()` returns consistent nonce counts across multiple calls during a signing session. If an Algorithm implementation returns different nonce specifications between the preprocess and sign phases, it causes an index out of bounds panic in `BindingFactor::nonces()`, resulting in a denial of service for that participant.

### Finding Description

**Exact Code Location:**

The vulnerability exists across multiple files in the FROST implementation: [1](#0-0) 

The `Algorithm` trait defines `nonces()` but does not enforce consistency across calls. [2](#0-1) 

During preprocess, `algorithm.nonces()` is called to create commitments. [3](#0-2) 

When reading preprocesses, `algorithm.nonces()` is called again. [4](#0-3) 

During signing, `algorithm.nonces()` is called a third time. [5](#0-4) 

The result is passed to `B.nonces()`. [6](#0-5) 

In `BindingFactor::nonces()`, the code accesses `commitments.nonces[n].generators[g]` at lines 204 and 206 without bounds checking, assuming the structure matches `planned_nonces`.

**Root Cause:**

The `Algorithm` trait's `nonces()` method signature takes `&self` but has no documented or enforced requirement that it must return the same value across multiple calls. While all current implementations (Schnorr, Bitcoin Schnorr, Schnorrkel) return constant values, the trait allows for implementations with mutable state via interior mutability patterns (RefCell, Mutex, etc.) that could return different nonce counts. [7](#0-6) 

When reading commitments, the structure is determined by the current return value of `algorithm.nonces()`, not validated against what was used during creation.

**Why Existing Mitigations Fail:**

No validation exists to ensure consistency. The code implicitly assumes `algorithm.nonces()` is pure/const but does not enforce this assumption through type system constraints, runtime checks, or documentation.

### Impact Explanation

**Specific Harm:**
A participant using an Algorithm implementation that returns inconsistent nonce counts will experience a panic during the signing phase, causing that participant to be unable to complete signing operations.

**Affected Parties:**
Only the participant with the buggy Algorithm implementation is affected. Other participants in the signing session are unaffected and cannot be exploited by this issue.

**Quantified Impact:**
- Denial of service for the affected participant's signing capability
- No fund loss
- No compromise of cryptographic security
- No impact on other participants

**Severity Justification:**
This qualifies as a LOW severity finding per the audit scope: "Undocumented panic reachable from a public API." The public APIs (`PreprocessMachine::preprocess()` and `SignMachine::sign()`) can panic without documented preconditions about Algorithm implementation requirements.

### Likelihood Explanation

**Required Capabilities:**
- Control over the Algorithm implementation being used
- Implementation of a stateful Algorithm that returns different nonce specifications

**Attack Complexity:**
- Cannot be exploited by external attackers
- Cannot be exploited by malicious co-signers
- Can only occur through programming error by the integrator

**Economic Feasibility:**
Not applicable - this is a defensive programming issue, not an exploitable vulnerability.

**Detection Risk:**
Easily detected during integration testing if the Algorithm implementation is buggy. Would immediately panic during the first signing attempt.

### Recommendation

**Proposed Fix:**

1. Add explicit documentation to the `Algorithm` trait specifying that `nonces()` must return consistent values across all calls for a given signing session: [8](#0-7) 

Add documentation: "INVARIANT: This method MUST return the same nonce specification (same outer Vec length and same inner Vec lengths) across all calls during a single signing session. Violating this invariant will cause a panic."

2. Add a runtime assertion in the signing phase to validate consistency:

In `AlgorithmSignMachine::sign()` after line 320, add validation that the nonce specification matches the structure of the stored preprocess commitments before proceeding to use them.

3. Consider using a marker trait or compile-time enforcement to ensure `nonces()` is const/pure, though this may be overly restrictive.

**Testing Recommendations:**
Add a test case with a deliberately inconsistent Algorithm implementation to verify the panic path and document expected behavior.

### Proof of Concept

**Exploitation Steps:**

1. Create an Algorithm implementation that uses interior mutability to track call count:

```rust
struct InconsistentAlgorithm {
    call_count: Cell<usize>,
    // ... other fields
}

impl Algorithm<C> for InconsistentAlgorithm {
    fn nonces(&self) -> Vec<Vec<C::G>> {
        let count = self.call_count.get();
        self.call_count.set(count + 1);
        
        if count < 2 {
            // Return 2 nonces during preprocess/read
            vec![vec![C::generator()], vec![C::generator()]]
        } else {
            // Return 3 nonces during sign
            vec![vec![C::generator()], vec![C::generator()], vec![C::generator()]]
        }
    }
    // ... other methods
}
```

2. Use this algorithm with AlgorithmMachine
3. Call preprocess() - creates commitments with 2 nonces
4. Call sign() - attempts to compute Rs with 3 nonces

**Expected Behavior:**
Should validate nonce consistency or document the requirement.

**Actual Behavior:**
Panics at `crypto/frost/src/nonce.rs` line 204 or 206 with index out of bounds when accessing `commitments.nonces[2]`.

### Citations

**File:** crypto/frost/src/algorithm.rs (L40-49)
```rust
  /// Obtain the list of nonces to generate, as specified by the generators to create commitments
  /// against per-nonce.
  ///
  /// The Algorithm is responsible for all transcripting of these nonce specifications/generators.
  ///
  /// The prover will be passed the commitments, and the commitments will be sent to all other
  /// participants. No guarantees the commitments are internally consistent (have the same discrete
  /// logarithm across generators) are made. Any Algorithm which specifies multiple generators for
  /// a single nonce must handle that itself.
  fn nonces(&self) -> Vec<Vec<C::G>>;
```

**File:** crypto/frost/src/sign.rs (L128-132)
```rust
    let (nonces, commitments) = Commitments::new::<_>(
      &mut rng,
      params.keys.original_secret_share(),
      &params.algorithm.nonces(),
    );
```

**File:** crypto/frost/src/sign.rs (L276-280)
```rust
  fn read_preprocess<R: Read>(&self, reader: &mut R) -> io::Result<Self::Preprocess> {
    Ok(Preprocess {
      commitments: Commitments::read::<_>(reader, &self.params.algorithm.nonces())?,
      addendum: self.params.algorithm.read_addendum(reader)?,
    })
```

**File:** crypto/frost/src/sign.rs (L320-320)
```rust
    let nonces = self.params.algorithm.nonces();
```

**File:** crypto/frost/src/sign.rs (L383-383)
```rust
    let Rs = B.nonces(&nonces);
```

**File:** crypto/frost/src/nonce.rs (L133-139)
```rust
  pub(crate) fn read<R: Read>(reader: &mut R, generators: &[Vec<C::G>]) -> io::Result<Self> {
    let nonces = (0 .. generators.len())
      .map(|i| NonceCommitments::read(reader, &generators[i]))
      .collect::<Result<Vec<NonceCommitments<C>>, _>>()?;

    Ok(Commitments { nonces })
  }
```

**File:** crypto/frost/src/nonce.rs (L194-212)
```rust
  pub(crate) fn nonces(&self, planned_nonces: &[Vec<C::G>]) -> Vec<Vec<C::G>> {
    let mut nonces = Vec::with_capacity(planned_nonces.len());
    for n in 0 .. planned_nonces.len() {
      nonces.push(Vec::with_capacity(planned_nonces[n].len()));
      for g in 0 .. planned_nonces[n].len() {
        #[allow(non_snake_case)]
        let mut D = C::G::identity();
        let mut statements = Vec::with_capacity(self.0.len());
        #[allow(non_snake_case)]
        for IndividualBinding { commitments, binding_factors } in self.0.values() {
          D += commitments.nonces[n].generators[g].0[0];
          statements
            .push((binding_factors.as_ref().unwrap()[n], commitments.nonces[n].generators[g].0[1]));
        }
        nonces[n].push(D + multiexp_vartime(&statements));
      }
    }
    nonces
  }
```
