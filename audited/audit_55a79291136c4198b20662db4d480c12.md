### Title
Mempool Transactions Treated as Finalized Completions, Blocking Retry Attempts and Violating Burn Accounting

### Summary
The `get_transaction()` function uses Bitcoin's `getrawtransaction` RPC with only the transaction ID, which returns transactions from both confirmed blocks and the mempool without distinction. When validators claim transaction completions, the system verifies them using `confirm_completion()`, which accepts mempool transactions as valid, permanently blocking retry attempts even if the transaction never confirms. This violates the critical invariant that "burns map to spendable external outputs."

### Finding Description

**Root Cause:**
The `get_transaction()` function in `networks/bitcoin/src/rpc.rs` calls the Bitcoin RPC `getrawtransaction` with only the transaction ID parameter. [1](#0-0) 

According to Bitcoin Core RPC documentation, `getrawtransaction` with only a txid parameter searches both the blockchain AND the mempool, returning unconfirmed transactions without any indication of their confirmation status.

**Vulnerable Flow:**
When a validator claims a transaction completion, the `confirm_completion()` function is called to verify the claim: [2](#0-1) 

This function calls `get_transaction()`, which returns `Ok(Some(transaction))` for BOTH confirmed and unconfirmed (mempool) transactions.

When `claimed_eventuality_completion()` receives this verification, it saves the completion to `CompletionsDb`: [3](#0-2) 

**Why Retries Are Blocked:**
The `already_completed()` function checks `CompletionsDb` to determine if a transaction is already complete: [4](#0-3) 

This function is called at the start of every retry attempt to prevent redundant signing: [5](#0-4) 

Once `CompletionsDb` contains an entry (even for a mempool transaction), all future retry attempts return `None`, permanently blocking new signing attempts.

**No Cleanup Mechanism:**
There is no mechanism to remove entries from `CompletionsDb` if the scanner never finds the transaction on-chain. The scanner only adds to `CompletedOnChainDb` when it finds transactions in confirmed blocks: [6](#0-5) 

But the retry blocking logic uses `CompletionsDb`, not `CompletedOnChainDb`, creating a permanent state inconsistency.

### Impact Explanation

**Direct Financial Loss:**
When users burn sriXYZ tokens (e.g., sriBTC) to withdraw to an external blockchain, the system creates and signs a Bitcoin transaction. If this transaction:
1. Enters the mempool but never confirms (due to low fees, network congestion, or mempool eviction)
2. Is verified as "complete" via `confirm_completion()` 
3. Later drops from the mempool or is double-spent

Then users lose their funds permanently because:
- Their sriXYZ tokens are already burned on Serai (irreversible)
- The external Bitcoin transaction never confirms (funds never received)
- The system cannot retry because it believes the transaction is complete

**Severity: Critical**
This directly violates critical invariant #5: "Mint/burn accounting: burns map to spendable external outputs." Users suffer complete loss of funds with no recovery mechanism.

**Quantifiable Impact:**
Every withdrawal transaction that enters mempool but fails to confirm results in 100% loss of the withdrawn amount for affected users. With Bitcoin transaction values potentially ranging from dust threshold (10,000 sats) to unlimited amounts, the cumulative loss could be substantial.

### Likelihood Explanation

**Natural Occurrence (High Likelihood):**
This vulnerability can trigger without any malicious behavior:
- Bitcoin network congestion causes transactions to be evicted from mempool
- Fee estimation errors result in insufficient fees for confirmation
- Mempool policy changes reject previously accepted transactions
- Network partitions cause different validators to see different mempool states

**Malicious Exploitation (Medium Complexity):**
An attacker with validator access can:
1. Publish a validly-signed transaction to their own node's mempool only
2. Send `ProcessorMessage::Completed` claiming the transaction is done
3. Other validators query their nodes, which may have the transaction in mempool (if connected to attacker's node)
4. Transaction is marked complete in `CompletionsDb`
5. Attacker never broadcasts to miners, transaction never confirms
6. System cannot retry, user funds are lost

**Attack Prerequisites:**
- Access to validator infrastructure (to send completion messages)
- Ability to publish to mempool without mining (trivial)
- No Byzantine cryptographic assumptions required

**Economic Feasibility:**
The attack cost is minimal (just transaction broadcast), while the benefit is the full value of the withdrawn funds if the attacker can double-spend or redirect them.

### Recommendation

**Primary Fix:**
Modify `get_transaction()` to explicitly verify transaction confirmation by requesting verbose output and checking the `confirmations` field, or by requiring a `blockhash` parameter:

```rust
// In networks/bitcoin/src/rpc.rs, modify get_transaction() to:
pub async fn get_transaction(&self, hash: &[u8; 32]) -> Result<Transaction, RpcError> {
  #[derive(Deserialize)]
  struct VerboseTx {
    hex: String,
    confirmations: Option<u64>,
  }
  
  let verbose_tx = self.rpc_call::<VerboseTx>("getrawtransaction", json!([hex::encode(hash), true])).await?;
  
  // Reject unconfirmed transactions
  if verbose_tx.confirmations.unwrap_or(0) == 0 {
    return Err(RpcError::InvalidResponse("transaction not confirmed"));
  }
  
  let bytes: Vec<u8> = FromHex::from_hex(&verbose_tx.hex)...
  // ... rest of existing verification
}
```

**Alternative Mitigation:**
Modify `already_completed()` to check `CompletedOnChainDb` instead of (or in addition to) `CompletionsDb`:

```rust
// In processor/src/signer.rs
fn already_completed(txn: &mut D::Transaction<'_>, id: [u8; 32]) -> bool {
  // Only block retries if scanner confirmed on-chain
  if CompletedOnChainDb::get(txn, &id).is_some() {
    return true;
  }
  false
}
```

**Testing Recommendations:**
1. Create integration test where transaction enters mempool but never confirms
2. Verify that retry attempts continue until on-chain confirmation
3. Test mempool eviction scenarios
4. Validate scanner-only completion path works correctly

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup:** User initiates withdrawal of 1 BTC worth of sriBTC to external Bitcoin address
   - Serai burns the sriBTC tokens
   - Validators create and sign Bitcoin transaction TX_A with txid TXID_A

2. **Attack Execution:**
   ```
   Validator M (attacker):
   - Receives signed TX_A
   - Publishes TX_A to own node's mempool only (not to miners)
   - Sends ProcessorMessage::Completed with claim = TXID_A
   ```

3. **Coordinator Processing:**
   ```
   - Creates Transaction::SignCompleted in tributary
   - Broadcasts CoordinatorMessage::Completed to all processors
   ```

4. **Honest Validators' Verification:**
   ```
   For each honest validator V:
   - Receives CoordinatorMessage::Completed with TXID_A
   - Calls claimed_eventuality_completion(id, TXID_A)
     - Calls confirm_completion(&eventuality, &TXID_A)
       - Calls get_transaction(&TXID_A)
         - Calls getrawtransaction(TXID_A)
         - Returns TX_A from mempool (confirmations = 0)
       - Returns Ok(Some(TX_A))  // ACCEPTS MEMPOOL TX
     - Writes to CompletionsDb
     - Returns Some(ProcessorMessage::Completed)
   ```

5. **State After Attack:**
   ```
   CompletionsDb[plan_id] = [TXID_A]
   CompletedOnChainDb[plan_id] = NOT SET (scanner never found it)
   ```

6. **Retry Attempt Blocked:**
   ```
   Coordinator schedules reattempt:
   - Calls signer.attempt(plan_id, attempt_num)
     - Calls already_completed(plan_id)
       - CompletionsDb::completions(plan_id) = [TXID_A]
       - Returns true
     - Returns None  // RETRY BLOCKED
   ```

7. **Final State:**
   ```
   - User's sriBTC: BURNED (irreversible)
   - User's BTC: NEVER RECEIVED (TX_A not in any block)
   - System state: Cannot retry (believes complete)
   - Result: PERMANENT LOSS OF FUNDS
   ```

**Expected Behavior:** System should only accept confirmed transactions (confirmations > 0) as valid completions and continue retry attempts until scanner confirms on-chain.

**Actual Behavior:** System accepts mempool transactions as valid completions, permanently blocking retries even when transactions never confirm.

### Citations

**File:** networks/bitcoin/src/rpc.rs (L210-225)
```rust
  /// Get a transaction by its hash.
  pub async fn get_transaction(&self, hash: &[u8; 32]) -> Result<Transaction, RpcError> {
    let hex = self.rpc_call::<String>("getrawtransaction", json!([hex::encode(hash)])).await?;
    let bytes: Vec<u8> = FromHex::from_hex(&hex)
      .map_err(|_| RpcError::InvalidResponse("node didn't use hex to encode the transaction"))?;
    let tx: Transaction = encode::deserialize(&bytes)
      .map_err(|_| RpcError::InvalidResponse("node sent an improperly serialized transaction"))?;

    let mut tx_hash = *tx.compute_txid().as_raw_hash().as_byte_array();
    tx_hash.reverse();
    if hash != &tx_hash {
      Err(RpcError::InvalidResponse("node replied with a different transaction"))?;
    }

    Ok(tx)
  }
```

**File:** processor/src/networks/bitcoin.rs (L855-863)
```rust
  async fn confirm_completion(
    &self,
    eventuality: &Self::Eventuality,
    _: &EmptyClaim,
  ) -> Result<Option<Transaction>, NetworkError> {
    Ok(Some(
      self.rpc.get_transaction(&eventuality.0).await.map_err(|_| NetworkError::ConnectionError)?,
    ))
  }
```

**File:** processor/src/signer.rs (L254-265)
```rust
  fn already_completed(txn: &mut D::Transaction<'_>, id: [u8; 32]) -> bool {
    if !CompletionsDb::completions::<N>(txn, id).is_empty() {
      debug!(
        "SignTransaction/Reattempt order for {}, which we've already completed signing",
        hex::encode(id)
      );

      true
    } else {
      false
    }
  }
```

**File:** processor/src/signer.rs (L289-306)
```rust
  pub fn completed(
    &mut self,
    txn: &mut D::Transaction<'_>,
    id: [u8; 32],
    completion: &<N::Eventuality as Eventuality>::Completion,
  ) -> Option<ProcessorMessage> {
    let first_completion = !Self::already_completed(txn, id);

    // Save this completion to the DB
    CompletedOnChainDb::complete_on_chain(txn, &id);
    CompletionsDb::complete::<N>(txn, id, completion);

    if first_completion {
      Some(self.complete(id, &N::Eventuality::claim(completion)))
    } else {
      None
    }
  }
```

**File:** processor/src/signer.rs (L311-333)
```rust
  async fn claimed_eventuality_completion(
    &mut self,
    txn: &mut D::Transaction<'_>,
    id: [u8; 32],
    claim: &<N::Eventuality as Eventuality>::Claim,
  ) -> Option<ProcessorMessage> {
    if let Some(eventuality) = EventualityDb::eventuality::<N>(txn, id) {
      match self.network.confirm_completion(&eventuality, claim).await {
        Ok(Some(completion)) => {
          info!(
            "signer eventuality for {} resolved in {}",
            hex::encode(id),
            hex::encode(claim.as_ref())
          );

          let first_completion = !Self::already_completed(txn, id);

          // Save this completion to the DB
          CompletionsDb::complete::<N>(txn, id, &completion);

          if first_completion {
            return Some(self.complete(id, claim));
          }
```

**File:** processor/src/signer.rs (L365-373)
```rust
  async fn attempt(
    &mut self,
    txn: &mut D::Transaction<'_>,
    id: [u8; 32],
    attempt: u32,
  ) -> Option<ProcessorMessage> {
    if Self::already_completed(txn, id) {
      return None;
    }
```
