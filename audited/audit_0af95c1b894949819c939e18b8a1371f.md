### Title
Identity Point Acceptance in DKG Commitments Enables Threshold Security Degradation

### Summary
The `Ciphersuite::read_G()` function used during PedPoP DKG commitment deserialization does not reject identity points, unlike the stricter `Curve::read_G()` variant. A malicious validator can submit commitments containing identity points with valid Schnorr proofs of possession (proving knowledge of discrete log zero), causing their polynomial to contribute nothing to the distributed secret. This reduces the effective number of participants from n to (n-k), where k malicious validators submit identity commitments, directly violating the t-of-n threshold security assumption and enabling secret recovery with fewer than t compromised honest participants.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `Ciphersuite::read_G()` function reads and validates group elements but only checks for valid decoding and canonical encoding. It does not explicitly reject the identity point. [2](#0-1) 

PedPoP DKG's commitment reading uses `C::read_G()` where `C` is the `Ciphersuite` trait, not the stricter `Curve` trait.

**Root Cause:**
Unlike `Curve::read_G()` which explicitly rejects identity: [3](#0-2) 

The `Ciphersuite::read_G()` has no such check. Since PedPoP uses the Ciphersuite variant, identity points pass validation.

**Exploitation Mechanism:**
A malicious validator can generate a polynomial with all zero coefficients (f_i(x) = 0), producing identity commitments C_{i,j} = g^0 = I. The Schnorr proof of possession verifies correctly because proving knowledge of discrete log zero is valid: [4](#0-3) 

When the secret share is zero, the proof equation holds: s = (c × 0) + r = r.

**Share Verification:** [5](#0-4) 

The share verification checks that ∑(i^j × C_j) - share × G = 0. When all commitments are identity, this requires share = 0, which is valid and passes verification at: [6](#0-5) 

**Aggregation Impact:** [7](#0-6) 

The verification shares are computed by summing commitments. Identity commitments contribute nothing (I + C = C), effectively removing that participant's contribution from the distributed secret.

### Impact Explanation

**Threshold Violation:**
In a t-of-n threshold scheme (e.g., t=5, n=7), if k=2 malicious validators submit identity commitments:
- Effective participants: n-k = 5
- Required honest compromises: t-k = 3 (instead of t=5)
- An adversary controlling 2 malicious validators + compromising 3 honest validators (total 5) can reconstruct the secret
- The security threshold is reduced from t to (t-k)

If k > n-t, the DKG fails entirely as insufficient participants contribute to the secret.

**Affected Parties:**
All Serai validators and users trusting the threshold multisig security. External assets (BTC, ETH, XMR) held in threshold wallets become vulnerable to unauthorized spending.

**Severity Justification:**
- **Critical Invariant Violation:** Violates invariant #1 (threshold correctness) and #2 (DKG integrity)
- **Protocol Scope:** Matches "Unintended, undocumented recovery of private spend keys (or key shares)" (Critical category)
- **Direct Impact:** Complete bypass of threshold security with realistic attack parameters

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a validator in the DKG session
- Needs to generate and submit DKG commitments (normal validator capability)
- No special cryptographic breaks required

**Attack Complexity:**
1. Generate polynomial with all zero coefficients
2. Compute identity commitments: C_j = g^0 = I for all j
3. Create valid Schnorr proof with secret=0, random nonce r
4. Submit commitments via standard DKG protocol
5. Send zero shares to other participants (mathematically required and valid)

**Economic Feasibility:**
- Cost: Validator bond/stake (existing requirement)
- Gain: Access to threshold wallet with potentially millions in external assets if combined with t-k honest validator compromises
- Highly economical for well-funded adversaries targeting cross-chain assets

**Detection Risk:**
Low. Identity points are valid group elements. Without explicit checks, they appear as legitimate commitments. The proof of possession verifies correctly, making the attack indistinguishable from honest behavior at the protocol level.

### Recommendation

**Primary Fix:**
Add explicit identity check in PedPoP commitment validation: [8](#0-7) 

After batch verification of proofs of knowledge, add:
```rust
for commitment in &msg.commitments {
  if bool::from(commitment.is_identity()) {
    Err(PedPoPError::InvalidCommitments(l))?;
  }
}
```

**Alternative Mitigation:**
Use `Curve::read_G()` instead of `Ciphersuite::read_G()` when reading commitments, as Curve explicitly rejects identity.

**Testing Recommendations:**
1. Unit test: Attempt to submit identity commitments and verify rejection
2. Integration test: Simulate k validators submitting identity with k ranging from 1 to n-t+1
3. Verify that threshold signatures require full t participants, not t-k

### Proof of Concept

**Attack Algorithm:**
```
Setup: t=5, n=7 threshold DKG
Adversary controls k=2 validators (indices 1 and 2)

For each malicious validator i ∈ {1,2}:
  1. Generate polynomial: f_i(x) = 0 (all coefficients = 0)
  2. Compute commitments: C_{i,j} = g^0 = I for j=0..t-1
  3. Generate Schnorr PoK:
     - Nonce: r = random()
     - R = g^r
     - Challenge: c = H(context, i, R, commitments)
     - Response: s = r + c×0 = r
     - Proof: (R, s) verifies as g^s = R + c×I = g^r + I = g^r = R ✓
  4. Submit commitments via DkgCommitments transaction
  5. When generating shares: s_{i,j} = f_i(j) = 0 for all j
  6. Send encrypted zero shares to all participants

Verification by honest participants:
  - Schnorr PoK verifies: multiexp([(1,R), (c,I), (-s,g)]) = R + I - rg = I ✓
  - Share verification: 0×g = ∑(j^k × I) = I ✓

Result:
  - Group secret distributed among only 5 honest validators
  - Adversary knows 2 shares are zero
  - Compromising 3 additional honest validators gives 5 shares total
  - Can reconstruct secret with 5 shares (threshold met)
  - **Threshold reduced from 5 to 3 honest participants**
```

**Expected vs Actual:**
- Expected: DKG rejects identity commitments, maintains t=5 threshold
- Actual: Identity commitments accepted, threshold reduced to t-k=3

### Citations

**File:** crypto/ciphersuite/src/lib.rs (L91-101)
```rust
  fn read_G<R: Read>(reader: &mut R) -> io::Result<Self::G> {
    let mut encoding = <Self::G as GroupEncoding>::Repr::default();
    reader.read_exact(encoding.as_mut())?;

    let point = Option::<Self::G>::from(Self::G::from_bytes(&encoding))
      .ok_or_else(|| io::Error::other("invalid point"))?;
    if point.to_bytes().as_ref() != encoding.as_ref() {
      Err(io::Error::other("non-canonical point"))?;
    }
    Ok(point)
  }
```

**File:** crypto/dkg/pedpop/src/lib.rs (L114-121)
```rust
    #[allow(non_snake_case)]
    let mut read_G = || -> io::Result<C::G> {
      let mut buf = <C::G as GroupEncoding>::Repr::default();
      reader.read_exact(buf.as_mut())?;
      let point = C::read_G(&mut buf.as_ref())?;
      cached_msg.extend(buf.as_ref());
      Ok(point)
    };
```

**File:** crypto/dkg/pedpop/src/lib.rs (L323-330)
```rust
      msg.sig.batch_verify(
        rng,
        &mut batch,
        l,
        msg.commitments[0],
        challenge::<C>(self.context, l, msg.sig.R.to_bytes().as_ref(), &msg.cached_msg),
      );

```

**File:** crypto/dkg/pedpop/src/lib.rs (L430-449)
```rust
fn share_verification_statements<C: Ciphersuite>(
  target: Participant,
  commitments: &[C::G],
  mut share: Zeroizing<C::F>,
) -> Vec<(C::F, C::G)> {
  // This can be insecurely linearized from n * t to just n using the below sums for a given
  // stripe. Doing so uses naive addition which is subject to malleability. The only way to
  // ensure that malleability isn't present is to use this n * t algorithm, which runs
  // per sender and not as an aggregate of all senders, which also enables blame
  let mut values = exponential::<C>(target, commitments);

  // Perform the share multiplication outside of the multiexp to minimize stack copying
  // While the multiexp BatchVerifier does zeroize its flattened multiexp, and itself, it still
  // converts whatever we give to an iterator and then builds a Vec internally, welcoming copies
  let neg_share_pub = C::generator() * -*share;
  share.zeroize();
  values.push((C::F::ONE, neg_share_pub));

  values
}
```

**File:** crypto/dkg/pedpop/src/lib.rs (L476-492)
```rust
    for (l, share_bytes) in shares.drain() {
      let (mut share_bytes, blame) =
        self.encryption.decrypt(rng, &mut batch, BatchId::Decryption(l), l, share_bytes);
      let share =
        Zeroizing::new(Option::<C::F>::from(C::F::from_repr(share_bytes.0)).ok_or_else(|| {
          PedPoPError::InvalidShare { participant: l, blame: Some(blame.clone()) }
        })?);
      share_bytes.zeroize();
      *self.secret += share.deref();

      blames.insert(l, blame);
      batch.queue(
        rng,
        BatchId::Share(l),
        share_verification_statements::<C>(self.params.i(), &self.commitments[&l], share),
      );
    }
```

**File:** crypto/dkg/pedpop/src/lib.rs (L501-521)
```rust
    // Stripe commitments per t and sum them in advance. Calculating verification shares relies on
    // these sums so preprocessing them is a massive speedup
    // If these weren't just sums, yet the tables used in multiexp, this would be further optimized
    // As of right now, each multiexp will regenerate them
    let mut stripes = Vec::with_capacity(usize::from(self.params.t()));
    for t in 0 .. usize::from(self.params.t()) {
      stripes.push(self.commitments.values().map(|commitments| commitments[t]).sum());
    }

    // Calculate each user's verification share
    let mut verification_shares = HashMap::new();
    for i in self.params.all_participant_indexes() {
      verification_shares.insert(
        i,
        if i == self.params.i() {
          C::generator() * self.secret.deref()
        } else {
          multiexp_vartime(&exponential::<C>(i, &stripes))
        },
      );
    }
```

**File:** crypto/frost/src/curve/mod.rs (L123-131)
```rust
  /// Read a point from a reader, rejecting identity.
  #[allow(non_snake_case)]
  fn read_G<R: Read>(reader: &mut R) -> io::Result<Self::G> {
    let res = <Self as Ciphersuite>::read_G(reader)?;
    if res.is_identity().into() {
      Err(io::Error::other("identity point"))?;
    }
    Ok(res)
  }
```

**File:** crypto/schnorr/src/lib.rs (L74-84)
```rust
  pub fn sign(
    private_key: &Zeroizing<C::F>,
    nonce: Zeroizing<C::F>,
    challenge: C::F,
  ) -> SchnorrSignature<C> {
    SchnorrSignature {
      // Uses deref instead of * as * returns C::F yet deref returns &C::F, preventing a copy
      R: C::generator() * nonce.deref(),
      s: (challenge * private_key.deref()) + nonce.deref(),
    }
  }
```
