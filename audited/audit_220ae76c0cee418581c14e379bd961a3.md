### Title
Missing Identity Validation in DKG Commitments and Verification Shares Allows Threshold Security Bypass

### Summary
The deserialization of DKG commitments and threshold key verification shares uses `Ciphersuite::read_G` which validates canonicality but does not reject the identity element, unlike nonce commitments which use `Curve::read_G` to explicitly reject identity. This inconsistency allows a malicious participant to broadcast identity commitments during DKG or enables attackers with database access to inject identity verification shares, permitting signature share forgery without knowledge of secret keys and effectively reducing the threshold security from t-of-n to (t-1)-of-(n-1).

### Finding Description

The `straus_vartime()` function in multiexp receives group element pairs and uses them directly without validation. [1](#0-0) 

Validation is expected to occur during deserialization. However, there is a critical inconsistency in how group elements are validated across the codebase:

**Properly validated (rejects identity):**
Nonce commitments use `Curve::read_G` which explicitly checks for and rejects identity elements: [2](#0-1) [3](#0-2) 

**Improperly validated (allows identity):**
Verification shares in ThresholdKeys deserialization use `Ciphersuite::read_G`: [4](#0-3) 

DKG commitments also use `Ciphersuite::read_G`: [5](#0-4) 

The `Ciphersuite::read_G` function only validates canonicality and curve membership, not identity: [6](#0-5) 

During DKG, commitments are validated via batch verification of Schnorr proof-of-possession signatures: [7](#0-6) 

When the public key (commitments[0]) is identity, the Schnorr verification equation becomes `R - s*G = 0`, which can be trivially satisfied by choosing any scalar `s` and setting `R = s*G`, allowing the proof-of-possession to be forged.

### Impact Explanation

A malicious participant can broadcast identity as their first commitment during DKG, successfully forge the proof-of-possession, and have their commitments accepted by all honest participants. This results in their verification share being identity or heavily influenced by identity.

During FROST signature share verification, the equation checked is: [8](#0-7) 

When verification_share is identity, this becomes `R + c*identity - s*G = 0`, simplifying to `R = s*G`. The attacker can forge valid signature shares by:
1. Choosing nonce `r` during preprocessing
2. Computing `R = r*G`  
3. Setting their signature share `s = r` (without any secret key component)
4. The verification passes: `s*G = r*G = R`

**Concrete Impact:**
- Attacker participates in threshold signing without possessing any secret key share
- Effective threshold is reduced from t-of-n to (t-1)-of-(n-1) without detection
- Violates Critical Invariant #1: "Threshold correctness: signatures are valid only with t-of-n participants"
- Violates Critical Invariant #2: "DKG integrity: shares and commitments are validated"

### Likelihood Explanation

**Attack Prerequisites:**
1. **DKG Attack Path:** Malicious participant during key generation who can broadcast identity commitments
2. **Database Attack Path:** Attacker with write access to processor database storage

**Attack Complexity:**
- DKG path requires being an accepted participant in key generation
- Coefficients are generated with `random_nonzero_F` during honest execution, but there is no validation preventing malicious identity commitments [9](#0-8) 

- Database path requires compromising the processor's storage (no encryption at rest)

**Detection Risk:**
- Attack is not immediately detectable as the malicious participant can produce valid-looking signature shares
- Group key computation includes the malicious contribution but appears valid
- Only cryptographic analysis would reveal the threshold weakness

**Economic Feasibility:**
- Enables participation in multisig operations without earning a key share through proper DKG
- Could facilitate insider attacks or unauthorized access to controlled assets

### Recommendation

**Primary Fix:**
Replace `Ciphersuite::read_G` with `Curve::read_G` for all DKG-related deserialization to ensure consistent identity rejection:

1. In `crypto/dkg/src/lib.rs` line 622, change verification shares deserialization to use `<C as Curve>::read_G(reader)?`

2. In `crypto/dkg/pedpop/src/lib.rs` line 118, change commitments deserialization to use `C::read_G(&mut buf.as_ref())?`

**Additional Validation:**
Add explicit identity checks in `ThresholdKeys::new()` to validate that no verification share is identity:

```rust
for verification_share in verification_shares.values() {
  if verification_share.is_identity().into() {
    Err(DkgError::IdentityVerificationShare)?;
  }
}
```

**Testing:**
- Add test cases attempting to deserialize ThresholdKeys with identity verification shares (should fail)
- Add test cases for DKG with malicious participant broadcasting identity commitments (should be rejected)
- Verify existing test vectors still pass with stricter validation

### Proof of Concept

**Exploitation Steps:**

1. **Malicious DKG Participant:**
   - During Round 1, construct commitments where `commitments[0] = identity`
   - Forge proof-of-possession: choose random scalar `s`, compute `R = s*G`, sign with `s` and `R`
   - Broadcast these commitments via encrypted message

2. **Honest Participants Accept:**
   - Commitments deserialized using `Ciphersuite::read_G` (allows identity)
   - PoK batch verification: `R + c*identity - s*G = R - s*G = 0` passes
   - Malicious commitments accepted and stored

3. **Verification Share Computed:**
   - Honest participants compute verification shares using accepted commitments
   - Malicious participant's verification share becomes identity or identity-influenced

4. **Signing Phase Exploitation:**
   - Malicious participant generates preprocess: choose nonce `r`, commit `R = r*G`
   - When signing, set share `s = r` (no secret key component)
   - Share verification: `s*G = R + c*identity` => `r*G = R` passes
   - Attacker successfully contributes to signature without secret key

**Expected vs Actual Behavior:**
- **Expected:** Identity elements rejected during deserialization, DKG validation fails
- **Actual:** Identity elements accepted, malicious participant can forge shares

### Citations

**File:** crypto/multiexp/src/straus.rs (L52-79)
```rust
pub(crate) fn straus_vartime<G: Group<Scalar: PrimeFieldBits>>(
  pairs: &[(G::Scalar, G)],
  window: u8,
) -> G {
  let groupings = prep_bits(pairs, window);
  let tables = prep_tables(pairs, window);

  let mut res: Option<G> = None;
  for b in (0 .. groupings[0].len()).rev() {
    if b != (groupings[0].len() - 1) {
      for _ in 0 .. window {
        res = res.map(|res| res.double());
      }
    }

    for s in 0 .. tables.len() {
      if groupings[s][b] != 0 {
        if let Some(res) = res.as_mut() {
          *res += tables[s][usize::from(groupings[s][b])];
        } else {
          res = Some(tables[s][usize::from(groupings[s][b])]);
        }
      }
    }
  }

  res.unwrap_or_else(G::identity)
}
```

**File:** crypto/frost/src/nonce.rs (L34-36)
```rust
  fn read<R: Read>(reader: &mut R) -> io::Result<GeneratorCommitments<C>> {
    Ok(GeneratorCommitments([<C as Curve>::read_G(reader)?, <C as Curve>::read_G(reader)?]))
  }
```

**File:** crypto/frost/src/curve/mod.rs (L123-131)
```rust
  /// Read a point from a reader, rejecting identity.
  #[allow(non_snake_case)]
  fn read_G<R: Read>(reader: &mut R) -> io::Result<Self::G> {
    let res = <Self as Ciphersuite>::read_G(reader)?;
    if res.is_identity().into() {
      Err(io::Error::other("identity point"))?;
    }
    Ok(res)
  }
```

**File:** crypto/dkg/src/lib.rs (L620-623)
```rust
    let mut verification_shares = HashMap::new();
    for l in (1 ..= n).map(Participant) {
      verification_shares.insert(l, <C as Ciphersuite>::read_G(reader)?);
    }
```

**File:** crypto/dkg/pedpop/src/lib.rs (L115-121)
```rust
    let mut read_G = || -> io::Result<C::G> {
      let mut buf = <C::G as GroupEncoding>::Repr::default();
      reader.read_exact(buf.as_mut())?;
      let point = C::read_G(&mut buf.as_ref())?;
      cached_msg.extend(buf.as_ref());
      Ok(point)
    };
```

**File:** crypto/dkg/pedpop/src/lib.rs (L167-167)
```rust
      coefficients.push(Zeroizing::new(C::random_nonzero_F(&mut *rng)));
```

**File:** crypto/dkg/pedpop/src/lib.rs (L321-334)
```rust
      // Step 5: Validate each proof of knowledge
      // This is solely the prep step for the latter batch verification
      msg.sig.batch_verify(
        rng,
        &mut batch,
        l,
        msg.commitments[0],
        challenge::<C>(self.context, l, msg.sig.R.to_bytes().as_ref(), &msg.cached_msg),
      );

      commitments.insert(l, msg.commitments.drain(..).collect::<Vec<_>>());
    }

    batch.verify_vartime_with_vartime_blame().map_err(PedPoPError::InvalidCommitments)?;
```

**File:** crypto/ciphersuite/src/lib.rs (L91-101)
```rust
  fn read_G<R: Read>(reader: &mut R) -> io::Result<Self::G> {
    let mut encoding = <Self::G as GroupEncoding>::Repr::default();
    reader.read_exact(encoding.as_mut())?;

    let point = Option::<Self::G>::from(Self::G::from_bytes(&encoding))
      .ok_or_else(|| io::Error::other("invalid point"))?;
    if point.to_bytes().as_ref() != encoding.as_ref() {
      Err(io::Error::other("non-canonical point"))?;
    }
    Ok(point)
  }
```

**File:** crypto/schnorr/src/lib.rs (L88-99)
```rust
  pub fn batch_statements(&self, public_key: C::G, challenge: C::F) -> [(C::F, C::G); 3] {
    // s = r + ca
    // sG == R + cA
    // R + cA - sG == 0
    [
      // R
      (C::F::ONE, self.R),
      // cA
      (challenge, public_key),
      // -sG
      (-self.s, C::generator()),
    ]
```
