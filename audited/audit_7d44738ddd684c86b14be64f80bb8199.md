### Title
Nonce Reuse in DKG Confirmation Across Concurrent Tributaries Enables Validator Key Share Recovery

### Summary
The coordinator's DkgConfirmer implementation caches FROST signing preprocesses using only the attempt number as the cache key, without including the tributary session or genesis identifier. During validator set handover periods, multiple concurrent tributaries can both perform DKG at the same attempt number, causing validators to reuse the same nonce across different signing sessions with different messages, enabling private key share recovery through standard nonce reuse attacks.

### Finding Description

The vulnerability exists in the DkgConfirmer's cached preprocess implementation. The cache key is constructed using only the attempt number: [1](#0-0) 

The CachedPreprocesses database lookup uses this context as the sole key: [2](#0-1) 

The encryption key used for the cached preprocess includes the validator's private key, meaning the same validator across different tributaries uses the same encryption/decryption key: [3](#0-2) 

The system supports multiple concurrent tributaries for different sessions: [4](#0-3) 

Each tributary has a unique session and genesis, but the cache key does NOT include these identifiers: [5](#0-4) [6](#0-5) 

The root cause is that the context tuple `(b"DkgConfirmer", attempt)` does not include `spec.genesis()`, `spec.set.session`, or any other tributary-specific identifier. When two concurrent tributaries both execute DKG at the same attempt number, they retrieve the same cached preprocess from the database, causing the validator to reuse the same nonce in two different signing contexts.

### Impact Explanation

This vulnerability enables complete recovery of a validator's private key share, which has catastrophic consequences:

1. **Key Share Recovery**: When a validator uses the same nonce r to sign two different messages m1 and m2, an attacker can compute the validator's private key share using the equation: `secret_share = (H(m1) - H(m2)) / (s1 - s2)` where s1 and s2 are the signature shares.

2. **Affected Parties**: All validators who participate in both the old and new validator sets during a handover period are vulnerable. This is typically the majority of validators during normal operations.

3. **Asset Loss**: With a validator's key share, an attacker who collects t shares (where t is the threshold) can sign arbitrary transactions, draining all funds controlled by that validator set's multisig wallets across all supported networks (Bitcoin, Ethereum, Monero, etc.).

4. **Systemic Risk**: During every validator set rotation, this creates a window where multiple validators' key shares can be compromised simultaneously, potentially allowing full control of the multisig.

This directly violates Critical Invariant #2: "DKG integrity: shares and commitments are validated; encrypted shares are bound to proofs-of-possession; no nonce/preprocess reuse."

### Likelihood Explanation

This vulnerability has HIGH likelihood of exploitation:

1. **Normal Operation Trigger**: Validator set rotations are routine events that happen at session boundaries. During the handover period, both the old set (completing its work) and new set (starting DKG) operate concurrently. This is not an edge case but standard operational behavior.

2. **DKG Timing**: If the old set is still completing DKG when the new set starts (both at attempt 0), nonce reuse occurs automatically without any attacker action required.

3. **Detection**: The nonce reuse is cryptographically observable by anyone monitoring the tributary blockchain. Signature shares from both signing sessions are publicly visible, allowing passive key share extraction.

4. **Attack Prerequisites**: No special capabilities required. An observer simply needs to:
   - Monitor DkgShares transactions during handover periods
   - Extract signature shares when the same validator signs in both sessions
   - Apply standard nonce reuse attack math to recover key shares

5. **Economic Feasibility**: Zero attack cost since it's passive observation. Potential gain is control over the entire multisig's assets.

### Recommendation

**Primary Fix**: Include the tributary genesis or session identifier in the cache key:

```rust
fn signing_protocol(&mut self) -> DkgConfirmerSigningProtocol<'_, T> {
  let context = (b"DkgConfirmer", self.spec.genesis(), self.attempt);
  SigningProtocol { key: self.key, spec: self.spec, txn: self.txn, context }
}
```

This ensures each tributary has its own cached preprocess namespace.

**Alternative Fix**: Remove caching entirely and generate fresh preprocesses for each call, matching the processor's safer design: [7](#0-6) 

**Additional Safeguards**:
1. Explicitly delete cached preprocesses after use
2. Add assertions to verify cached preprocesses haven't been used before
3. Include unit tests that verify concurrent tributaries don't share preprocesses

### Proof of Concept

**Setup Conditions**:
1. Validator V is in both Session N and Session N+1 validator sets
2. Old tributary (Session N) is performing DKG attempt 0
3. New tributary (Session N+1) starts DKG attempt 0 concurrently

**Exploitation Steps**:

1. Old tributary calls `dkg_confirmation_nonces(key, spec_N, txn, attempt=0)`:
   - Generates nonce pair (d, e) and caches at key `("DkgConfirmer", 0)`
   - Returns commitments D = d*G, E = e*G

2. New tributary calls `dkg_confirmation_nonces(key, spec_N+1, txn, attempt=0)`:
   - Retrieves SAME cached nonce (d, e) from key `("DkgConfirmer", 0)`
   - Returns commitments D = d*G, E = e*G (identical)

3. Old tributary creates signature share for key_pair_1:
   - `share_1 = d + e*binding_1 + secret_share * challenge_1`

4. New tributary creates signature share for key_pair_2:
   - `share_2 = d + e*binding_2 + secret_share * challenge_2`

5. Attacker observes both signature shares and extracts:
   - `secret_share = (share_1 - share_2 - e*(binding_1 - binding_2)) / (challenge_1 - challenge_2)`

**Expected vs Actual**:
- Expected: Each tributary uses fresh, independent nonces
- Actual: Both tributaries reuse the same nonce, enabling key share recovery

### Citations

**File:** coordinator/src/tributary/signing_protocol.rs (L107-115)
```rust
    let mut encryption_key = {
      let mut encryption_key_preimage =
        Zeroizing::new(b"Cached Preprocess Encryption Key".to_vec());
      encryption_key_preimage.extend(self.context.encode());
      let repr = Zeroizing::new(self.key.to_repr());
      encryption_key_preimage.extend(repr.deref());
      Blake2s256::digest(&encryption_key_preimage)
    };
    let encryption_key_slice: &mut [u8] = encryption_key.as_mut();
```

**File:** coordinator/src/tributary/signing_protocol.rs (L123-145)
```rust
    if CachedPreprocesses::get(self.txn, &self.context).is_none() {
      let (machine, _) =
        AlgorithmMachine::new(algorithm.clone(), keys.clone()).preprocess(&mut OsRng);

      let mut cache = machine.cache();
      assert_eq!(cache.0.len(), 32);
      #[allow(clippy::needless_range_loop)]
      for b in 0 .. 32 {
        cache.0[b] ^= encryption_key_slice[b];
      }

      CachedPreprocesses::set(self.txn, &self.context, &cache.0);
    }

    let cached = CachedPreprocesses::get(self.txn, &self.context).unwrap();
    let mut cached: Zeroizing<[u8; 32]> = Zeroizing::new(cached);
    #[allow(clippy::needless_range_loop)]
    for b in 0 .. 32 {
      cached[b] ^= encryption_key_slice[b];
    }
    encryption_key_slice.zeroize();
    let (machine, preprocess) =
      AlgorithmSignMachine::from_cache(algorithm, keys, CachedPreprocess(cached));
```

**File:** coordinator/src/tributary/signing_protocol.rs (L274-277)
```rust
  fn signing_protocol(&mut self) -> DkgConfirmerSigningProtocol<'_, T> {
    let context = (b"DkgConfirmer", self.attempt);
    SigningProtocol { key: self.key, spec: self.spec, txn: self.txn, context }
  }
```

**File:** coordinator/src/main.rs (L150-150)
```rust
  tributaries: &HashMap<Session, ActiveTributary<D, P>>,
```

**File:** coordinator/src/tributary/spec.rs (L43-53)
```rust
#[derive(Clone, PartialEq, Eq, Debug, BorshSerialize, BorshDeserialize)]
pub struct TributarySpec {
  serai_block: [u8; 32],
  start_time: u64,
  set: ExternalValidatorSet,
  #[borsh(
    serialize_with = "borsh_serialize_validators",
    deserialize_with = "borsh_deserialize_validators"
  )]
  validators: Vec<(<Ristretto as Ciphersuite>::G, u16)>,
}
```

**File:** coordinator/src/tributary/spec.rs (L76-86)
```rust
  pub fn genesis(&self) -> [u8; 32] {
    // Calculate the genesis for this Tributary
    let mut genesis = RecommendedTranscript::new(b"Serai Tributary Genesis");
    // This locks it to a specific Serai chain
    genesis.append_message(b"serai_block", self.serai_block);
    genesis.append_message(b"session", self.set.session.0.to_le_bytes());
    genesis.append_message(b"network", self.set.network.encode());
    let genesis = genesis.challenge(b"genesis");
    let genesis_ref: &[u8] = genesis.as_ref();
    genesis_ref[.. 32].try_into().unwrap()
  }
```

**File:** processor/src/batch_signer.rs (L171-183)
```rust
    let mut machines = vec![];
    let mut preprocesses = vec![];
    let mut serialized_preprocesses = vec![];
    for keys in &self.keys {
      // b"substrate" is a literal from sp-core
      let machine = AlgorithmMachine::new(Schnorrkel::new(b"substrate"), keys.clone());

      let (machine, preprocess) = machine.preprocess(&mut OsRng);
      machines.push(machine);
      serialized_preprocesses.push(preprocess.serialize().try_into().unwrap());
      preprocesses.push(preprocess);
    }
    self.preprocessing.insert(id, (machines, preprocesses));
```
