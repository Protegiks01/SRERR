### Title
Undocumented Panic in FROST Signing When Algorithm.nonces() Returns Empty Vector

### Summary
The FROST signing implementation does not validate that `Algorithm.nonces()` returns a non-empty vector. Preprocess generation succeeds with zero nonces, but signing later panics with an index out of bounds error when attempting to access the first nonce. This undocumented panic is reachable through the public `Algorithm` trait.

### Finding Description

**Exact Code Location:**
- `crypto/frost/src/sign.rs`, function `seeded_preprocess()`, lines 121-144
- `crypto/frost/src/algorithm.rs`, function `sign_share()`, lines 201-211

**Root Cause:**
The `Algorithm` trait's `nonces()` method documentation does not specify that it must return a non-empty vector. [1](#0-0) 

When `algorithm.nonces()` returns an empty vector during preprocess generation, `Commitments::new()` silently creates empty nonce and commitment vectors without any validation. [2](#0-1) 

The preprocess completes successfully with these empty vectors. [3](#0-2) 

However, during the signing phase, the Schnorr implementation's `sign_share()` method attempts to access `nonce_sums[0][0]` without checking if the vector is non-empty, causing an index out of bounds panic. [4](#0-3) 

**Why Existing Mitigations Fail:**
There are no validation checks on the length of the nonces vector returned by `algorithm.nonces()` at any point in the preprocessing or signing flow. The documentation does not specify this requirement, and no assertions or error handling prevent the empty vector case.

### Impact Explanation

**Specific Harm:**
Users implementing custom `Algorithm` trait instances may unknowingly return an empty vector from `nonces()`, causing their signing operations to panic with an unhelpful "index out of bounds" error message rather than a clear validation error.

**Who Is Affected:**
Developers creating custom algorithm implementations for the FROST library. Standard implementations (Schnorr, Schnorrkel, Bitcoin) are not affected as they all return non-empty vectors. [5](#0-4) 

**Severity Justification:**
This is a Low severity issue as categorized in the Protocol Scope: "Undocumented panic reachable from a public API". While it causes a panic (DoS), it only affects users with custom implementations and does not compromise cryptographic security, key material, or enable signature forgery.

### Likelihood Explanation

**Required Attacker Capabilities:**
No attacker required - this is a programming error by library users implementing the public `Algorithm` trait.

**Attack Complexity:**
Low - simply implement `Algorithm` with `nonces()` returning `vec![]` and attempt to sign.

**Realistic Steps:**
1. Implement a custom `Algorithm` for a new signature scheme
2. Return `vec![]` from `nonces()` method (possibly believing nonces are not needed)
3. Call `preprocess()` - succeeds
4. Call `sign()` - panic occurs at `nonce_sums[0][0]` access

**Economic Feasibility:**
Not applicable - this is a self-inflicted issue, not an attack vector.

**Detection Risk:**
The panic would be immediately apparent during testing, but the root cause may not be obvious without examining the FROST library internals.

### Recommendation

**Proposed Code Changes:**

1. Add validation in `seeded_preprocess()` after calling `algorithm.nonces()`:
```rust
let nonces_spec = params.algorithm.nonces();
if nonces_spec.is_empty() {
  panic!("Algorithm.nonces() must return at least one nonce specification");
}
```

2. Update the `Algorithm` trait documentation to explicitly state the requirement:
```rust
/// Obtain the list of nonces to generate, as specified by the generators to create commitments
/// against per-nonce.
///
/// This must return at least one nonce specification (non-empty vector). Returning an empty
/// vector will cause a panic during signing.
```

3. Consider adding a debug assertion or returning a `Result` from `preprocess()` to provide clearer error messaging.

**Alternative Mitigations:**
Use Rust's type system to enforce non-emptiness at compile time by using `NonEmpty<Vec<Vec<C::G>>>` or similar, though this would be a breaking API change.

**Testing Recommendations:**
Add a test case that verifies an empty nonces specification is caught during preprocess or produces a clear error message rather than panicking during signing.

### Proof of Concept

**Exploitation Steps:**

1. Create a minimal `Algorithm` implementation:
```rust
struct EmptyNonceAlgorithm<C: Curve> {
    transcript: RecommendedTranscript,
    _phantom: PhantomData<C>,
}

impl<C: Curve> Algorithm<C> for EmptyNonceAlgorithm<C> {
    type Transcript = RecommendedTranscript;
    type Addendum = ();
    type Signature = ();
    
    fn nonces(&self) -> Vec<Vec<C::G>> {
        vec![]  // Returns empty vector
    }
    
    // ... other required methods
}
```

2. Use it with FROST:
```rust
let keys = /* generate threshold keys */;
let machine = AlgorithmMachine::new(EmptyNonceAlgorithm::new(), keys);
let (sign_machine, preprocess) = machine.preprocess(&mut rng);
// Preprocess succeeds

let result = sign_machine.sign(preprocesses, b"message");
// Panics with: "index out of bounds: the len is 0 but the index is 0"
```

**Expected Behavior:**
Preprocess should fail with a clear error message indicating that `nonces()` must return a non-empty vector.

**Actual Behavior:**
Preprocess succeeds, but signing panics with an unclear index out of bounds error at line 208 of `algorithm.rs`.

### Citations

**File:** crypto/frost/src/algorithm.rs (L40-49)
```rust
  /// Obtain the list of nonces to generate, as specified by the generators to create commitments
  /// against per-nonce.
  ///
  /// The Algorithm is responsible for all transcripting of these nonce specifications/generators.
  ///
  /// The prover will be passed the commitments, and the commitments will be sent to all other
  /// participants. No guarantees the commitments are internally consistent (have the same discrete
  /// logarithm across generators) are made. Any Algorithm which specifies multiple generators for
  /// a single nonce must handle that itself.
  fn nonces(&self) -> Vec<Vec<C::G>>;
```

**File:** crypto/frost/src/algorithm.rs (L182-184)
```rust
  fn nonces(&self) -> Vec<Vec<C::G>> {
    vec![vec![C::generator()]]
  }
```

**File:** crypto/frost/src/algorithm.rs (L201-211)
```rust
  fn sign_share(
    &mut self,
    params: &ThresholdView<C>,
    nonce_sums: &[Vec<C::G>],
    mut nonces: Vec<Zeroizing<C::F>>,
    msg: &[u8],
  ) -> C::F {
    let c = H::hram(&nonce_sums[0][0], &params.group_key(), msg);
    self.c = Some(c);
    SchnorrSignature::<C>::sign(params.secret_share(), nonces.swap_remove(0), c).s
  }
```

**File:** crypto/frost/src/nonce.rs (L107-124)
```rust
  pub(crate) fn new<R: RngCore + CryptoRng>(
    rng: &mut R,
    secret_share: &Zeroizing<C::F>,
    planned_nonces: &[Vec<C::G>],
  ) -> (Vec<Nonce<C>>, Commitments<C>) {
    let mut nonces = vec![];
    let mut commitments = vec![];

    for generators in planned_nonces {
      let (nonce, these_commitments): (Nonce<C>, _) =
        NonceCommitments::new(&mut *rng, secret_share, generators);

      nonces.push(nonce);
      commitments.push(these_commitments);
    }

    (nonces, Commitments { nonces: commitments })
  }
```

**File:** crypto/frost/src/sign.rs (L121-144)
```rust
  fn seeded_preprocess(
    self,
    seed: CachedPreprocess,
  ) -> (AlgorithmSignMachine<C, A>, Preprocess<C, A::Addendum>) {
    let mut params = self.params;

    let mut rng = ChaCha20Rng::from_seed(*seed.0);
    let (nonces, commitments) = Commitments::new::<_>(
      &mut rng,
      params.keys.original_secret_share(),
      &params.algorithm.nonces(),
    );
    let addendum = params.algorithm.preprocess_addendum(&mut rng, &params.keys);

    let preprocess = Preprocess { commitments, addendum };

    // Also obtain entropy to randomly sort the included participants if we need to identify blame
    let mut blame_entropy = [0; 32];
    rng.fill_bytes(&mut blame_entropy);
    (
      AlgorithmSignMachine { params, seed, nonces, preprocess: preprocess.clone(), blame_entropy },
      preprocess,
    )
  }
```
