### Title
Undocumented Panic in Schnorr::verify_share() Due to Missing Bounds Check on Nonces Parameter

### Summary
The `Schnorr::verify_share()` function in the FROST library accesses `nonces[0][0]` without validating that the nonces slice is non-empty or that the first element contains at least one item. This creates an undocumented precondition that, when violated by direct API callers, causes a panic and potential denial of service.

### Finding Description

The vulnerability exists in the `Schnorr` implementation of the `Algorithm` trait's `verify_share()` method: [1](#0-0) 

At line 226, the code directly accesses `nonces[0][0]` without any bounds checking. If the `nonces` parameter is an empty slice or contains an empty inner vector, this will panic with an index out of bounds error.

The `Algorithm` trait itself is publicly exposed: [2](#0-1) 

The `Schnorr` type can be instantiated by external callers via its public constructor: [3](#0-2) 

The trait method documentation provides no preconditions regarding the nonces parameter structure: [4](#0-3) 

While Serai's internal signing machinery is protected from this issue through the `Commitments::read()` function that enforces structural consistency: [5](#0-4) 

The public API remains vulnerable to direct misuse by external library consumers.

### Impact Explanation

The impact is limited to a denial of service affecting code that directly uses the modular-frost library's public API:

**Affected parties:**
- External developers using the modular-frost library (published crate): [6](#0-5) 

- Any code path that calls `verify_share()` directly with unvalidated input

**Specific harm:**
- Panic causes immediate thread/process termination
- No recovery mechanism for the panic
- Potential service disruption if used in production systems

**Severity justification:**
This matches the protocol scope definition of "Low: Undocumented panic reachable from a public API". Serai's internal usage through the signing machinery is not vulnerable because preprocessing validation ensures correct nonce structure, but the public library API lacks defensive programming.

### Likelihood Explanation

**Required attacker capabilities:**
- Ability to call the public API directly (trivial for any library user)
- No special privileges or cryptographic knowledge required

**Attack complexity:**
- Minimal: Simply instantiate `Schnorr` and call `verify_share()` with empty vectors
- No protocol-level exploitation possible against Serai validators

**Economic feasibility:**
- Free for any library consumer
- Not exploitable through Serai's validator network protocol

**Detection risk:**
- Immediate detection (panic is logged)
- Clear error message identifies the issue

**Operational constraints:**
- Serai's internal usage via the signing machinery validates all preprocesses through `Commitments::read()`, which enforces the expected structure from `algorithm.nonces()`: [7](#0-6) 

Therefore, malicious validators cannot trigger this through the protocol. The vulnerability only affects direct API usage outside Serai's controlled code paths.

### Recommendation

Add bounds validation at the start of `verify_share()`:

```rust
fn verify_share(
  &self,
  verification_share: C::G,
  nonces: &[Vec<C::G>],
  share: C::F,
) -> Result<Vec<(C::F, C::G)>, ()> {
  // Validate nonces structure
  if nonces.is_empty() || nonces[0].is_empty() {
    return Err(());
  }
  
  Ok(
    SchnorrSignature::<C> { R: nonces[0][0], s: share }
      .batch_statements(verification_share, self.c.unwrap())
      .to_vec(),
  )
}
```

Alternative: Document the precondition clearly in the trait documentation:
```rust
/// Verify a specific share given as a response.
/// 
/// # Preconditions
/// - `nonces` must match the structure returned by `Algorithm::nonces()`
/// - For Schnorr, this requires `nonces.len() >= 1` and `nonces[0].len() >= 1`
/// 
/// # Panics
/// Panics if the nonces structure is invalid.
```

**Testing recommendations:**
- Add unit tests verifying graceful error handling with empty nonces
- Add fuzzing tests for `verify_share()` with arbitrary input structures

### Proof of Concept

```rust
use frost::{
  Curve,
  algorithm::{Algorithm, Schnorr, Hram},
};
use transcript::RecommendedTranscript;

// Minimal Hram implementation for PoC
struct TestHram;
impl<C: Curve> Hram<C> for TestHram {
  fn hram(_: &C::G, _: &C::G, _: &[u8]) -> C::F {
    C::F::ZERO
  }
}

fn trigger_panic<C: Curve>() {
  // Create a Schnorr instance (public API)
  let schnorr = Schnorr::<C, RecommendedTranscript, TestHram>::new(
    RecommendedTranscript::new(b"test")
  );
  
  // Call verify_share with empty nonces
  let empty_nonces: Vec<Vec<C::G>> = vec![];
  
  // This will panic with "index out of bounds: the len is 0 but the index is 0"
  let _ = schnorr.verify_share(
    C::G::generator(),
    &empty_nonces,  // Invalid: empty slice
    C::F::ZERO,
  );
}

// Alternative: nonces with empty inner vector
fn trigger_panic_variant<C: Curve>() {
  let schnorr = Schnorr::<C, RecommendedTranscript, TestHram>::new(
    RecommendedTranscript::new(b"test")
  );
  
  let invalid_nonces = vec![vec![]];  // First element is empty
  
  // This will panic with "index out of bounds: the len is 0 but the index is 0"
  let _ = schnorr.verify_share(
    C::G::generator(),
    &invalid_nonces,
    C::F::ZERO,
  );
}
```

**Expected behavior:** `verify_share` should return `Err(())` for invalid input structure

**Actual behavior:** Panic with "index out of bounds" error, crashing the calling thread

### Citations

**File:** crypto/frost/src/algorithm.rs (L85-94)
```rust
  /// Verify a specific share given as a response.
  /// This function should return a series of pairs whose products should sum to zero for a valid
  /// share. Any error raised is treated as the share being invalid.
  #[allow(clippy::type_complexity, clippy::result_unit_err)]
  fn verify_share(
    &self,
    verification_share: C::G,
    nonces: &[Vec<C::G>],
    share: C::F,
  ) -> Result<Vec<(C::F, C::G)>, ()>;
```

**File:** crypto/frost/src/algorithm.rs (L158-161)
```rust
  /// Construct a Schnorr algorithm continuing the specified transcript.
  pub fn new(transcript: T) -> Schnorr<C, T, H> {
    Schnorr { transcript, c: None, _hram: PhantomData }
  }
```

**File:** crypto/frost/src/algorithm.rs (L219-230)
```rust
  fn verify_share(
    &self,
    verification_share: C::G,
    nonces: &[Vec<C::G>],
    share: C::F,
  ) -> Result<Vec<(C::F, C::G)>, ()> {
    Ok(
      SchnorrSignature::<C> { R: nonces[0][0], s: share }
        .batch_statements(verification_share, self.c.unwrap())
        .to_vec(),
    )
  }
```

**File:** crypto/frost/src/lib.rs (L16-17)
```rust
/// Algorithm for the signing process.
pub mod algorithm;
```

**File:** crypto/frost/src/sign.rs (L276-280)
```rust
  fn read_preprocess<R: Read>(&self, reader: &mut R) -> io::Result<Self::Preprocess> {
    Ok(Preprocess {
      commitments: Commitments::read::<_>(reader, &self.params.algorithm.nonces())?,
      addendum: self.params.algorithm.read_addendum(reader)?,
    })
```

**File:** crypto/frost/Cargo.toml (L2-6)
```text
name = "modular-frost"
version = "0.10.1"
description = "Modular implementation of FROST over ff/group"
license = "MIT"
repository = "https://github.com/serai-dex/serai/tree/develop/crypto/frost"
```

**File:** crypto/frost/src/nonce.rs (L133-138)
```rust
  pub(crate) fn read<R: Read>(reader: &mut R, generators: &[Vec<C::G>]) -> io::Result<Self> {
    let nonces = (0 .. generators.len())
      .map(|i| NonceCommitments::read(reader, &generators[i]))
      .collect::<Result<Vec<NonceCommitments<C>>, _>>()?;

    Ok(Commitments { nonces })
```
