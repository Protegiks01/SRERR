### Title
Secret Share Leakage via Unzeroized Hash Input Buffers in FROST Nonce Generation

### Summary
The `hash_to_F()` function in dalek-ff-group and ed448 ciphersuites creates temporary concatenated buffers using `.concat()` that are not explicitly zeroized before deallocation. During FROST nonce generation, these buffers contain secret share data that persists in heap memory after use, allowing recovery of threshold signing key shares via memory dumps or privileged access.

### Finding Description

**Exact Code Locations:** [1](#0-0) [2](#0-1) 

**Root Cause:**

The `hash_to_F()` implementations use `[dst, data].concat()` to create a temporary `Vec<u8>` containing the concatenated input. In Rust, `Vec<u8>` does not automatically zeroize memory on drop - it only deallocates. This temporary buffer remains in the heap and can be recovered until the allocator reuses that memory.

**Secret Data Flow:**

The vulnerability is triggered during FROST nonce generation: [3](#0-2) 

At line 112, `hash_to_F` is called with `seed.deref()` which contains:
- 32 random bytes (line 98-99)
- The participant's secret share representation (line 111: `seed.extend(repr.as_ref())`)

This secret data flows through the Curve trait's `hash_to_F` wrapper (line 56-58), which creates another concat buffer, then into the Ciphersuite's `hash_to_F` where the unzeroized buffer is created. [4](#0-3) 

**Why Existing Mitigations Fail:**

The codebase extensively uses `Zeroizing` wrappers to protect secret data (as seen in the `random_nonce` function where `seed`, `repr`, and `res` are all zeroized). However, the intermediate buffer created by `.concat()` inside `hash_to_F` is outside this protection boundary.

The kp256 implementation demonstrates awareness of this issue by explicitly zeroizing intermediate values: [5](#0-4) 

However, the dalek and ed448 implementations do not follow this pattern.

### Impact Explanation

**Specific Harm:**
- Secret shares from threshold signing participants persist in unzeroized heap memory
- An attacker who obtains a memory dump can extract these shares
- With t shares (where t = n * 2/3 + 1), the attacker can reconstruct the full private key
- This breaks the security of the entire threshold signature scheme

**Affected Parties:**
- All validators using Ristretto, Ed25519, or Ed448 ciphersuites for FROST signatures
- Any external chain assets controlled by compromised threshold keys

**Severity Justification:**
According to the protocol scope, this is a **CRITICAL** vulnerability as it enables "Unintended, undocumented recovery of private spend keys (or key shares)". The impact includes:
- Complete compromise of threshold wallet security
- Ability to sign arbitrary transactions on external chains (Bitcoin, Ethereum, Monero)
- Loss of all assets controlled by the compromised multisig
- Violation of Critical Invariant #2 (DKG integrity)

### Likelihood Explanation

**Required Attacker Capabilities:**
- Access to process memory via one of:
  - Core dumps from process crashes
  - Debug/diagnostic tools on the host system
  - Privileged malware with memory scanning capabilities
  - Cloud provider memory snapshots
  - Swap files if swap is enabled

**Attack Complexity:**
- Low to Medium: Memory dump acquisition varies by environment
- Pattern matching for 32-64 byte sequences in heap memory
- Multiple opportunities on every signature operation

**Economic Feasibility:**
- High reward: Full control of external chain assets worth potentially millions
- Low cost: Memory dump techniques are well-documented
- Detection risk: Memory dumps may occur legitimately (crashes, debugging) without raising suspicion

**Realistic Exploitation:**
1. Attacker deploys malware or exploits system vulnerability to gain privileged access
2. Captures memory dump during or shortly after FROST signing operations
3. Scans heap memory for characteristic patterns (nonce DST prefix + random data + share representation)
4. Extracts sufficient shares to reconstruct private key
5. Uses reconstructed key to drain all assets from threshold-controlled wallets

### Recommendation

**Immediate Fix:**

Replace the unzeroized `.concat()` calls with a zeroizing approach:

```rust
fn hash_to_F(dst: &[u8], data: &[u8]) -> Self::F {
  use zeroize::Zeroizing;
  let mut buffer = Zeroizing::new(Vec::with_capacity(dst.len() + data.len()));
  buffer.extend_from_slice(dst);
  buffer.extend_from_slice(data);
  Scalar::from_hash(Sha512::new_with_prefix(&buffer))
}
```

Apply this fix to:
- crypto/dalek-ff-group/src/ciphersuite.rs line 31-33
- crypto/ed448/src/ciphersuite.rs line 71-73
- crypto/frost/src/curve/mod.rs line 57 (the wrapper that also uses concat)

**Testing Recommendations:**
1. Verify secret data is zeroized by inspecting memory dumps in test environments
2. Add regression tests that verify no secret material persists in memory after operations
3. Audit all other uses of `.concat()` for similar issues
4. Consider using memory sanitizers (MSAN, Valgrind) to detect unzeroized secret data

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Run a Serai validator node using Ristretto/Ed25519 ciphersuite
2. **Trigger**: Perform FROST signing operation which calls `random_nonce()`
3. **Capture**: Immediately capture process memory via:
   - `gcore <pid>` (Linux)
   - Crash the process and examine core dump
   - Read `/proc/<pid>/mem` with appropriate privileges
4. **Extract**: Search heap memory for patterns:
   - Look for 32 random bytes followed by 32-byte secret share representation
   - Pattern appears after nonce DST (e.g., "nonce" or "FROST-RISTRETTO255-SHA512-v11nonce")
5. **Reconstruct**: Collect t shares from different validator memory dumps
6. **Exploit**: Use reconstructed private key to sign arbitrary transactions

**Expected vs Actual Behavior:**

Expected: All buffers containing secret share data should be zeroized immediately after use, leaving no recoverable traces in memory.

Actual: The concatenated buffer in `hash_to_F()` is deallocated but not zeroized, leaving secret share data recoverable in heap memory until that memory is reused by the allocator.

**Validation:**
The presence of this vulnerability can be confirmed by:
1. Setting a breakpoint after `hash_to_F` returns
2. Examining heap memory for the input buffer contents
3. Observing that the buffer remains readable despite the Vec being dropped

### Citations

**File:** crypto/dalek-ff-group/src/ciphersuite.rs (L31-33)
```rust
      fn hash_to_F(dst: &[u8], data: &[u8]) -> Self::F {
        Scalar::from_hash(Sha512::new_with_prefix(&[dst, data].concat()))
      }
```

**File:** crypto/ed448/src/ciphersuite.rs (L71-73)
```rust
  fn hash_to_F(dst: &[u8], data: &[u8]) -> Self::F {
    Scalar::wide_reduce(Self::H::digest([dst, data].concat()).as_ref().try_into().unwrap())
  }
```

**File:** crypto/frost/src/curve/mod.rs (L56-58)
```rust
  fn hash_to_F(dst: &[u8], msg: &[u8]) -> Self::F {
    <Self as Ciphersuite>::hash_to_F(&[Self::CONTEXT, dst].concat(), msg)
  }
```

**File:** crypto/frost/src/curve/mod.rs (L94-121)
```rust
  fn random_nonce<R: RngCore + CryptoRng>(
    secret: &Zeroizing<Self::F>,
    rng: &mut R,
  ) -> Zeroizing<Self::F> {
    let mut seed = Zeroizing::new(vec![0; 32]);
    rng.fill_bytes(seed.as_mut());

    let mut repr = secret.to_repr();

    // Perform rejection sampling until we reach a non-zero nonce
    // While the IETF spec doesn't explicitly require this, generating a zero nonce will produce
    // commitments which will be rejected for being zero (and if they were used, leak the secret
    // share)
    // Rejection sampling here will prevent an honest participant from ever generating 'malicious'
    // values and ensure safety
    let mut res;
    while {
      seed.extend(repr.as_ref());
      res = Zeroizing::new(<Self as Curve>::hash_to_F(b"nonce", seed.deref()));
      res.ct_eq(&Self::F::ZERO).into()
    } {
      seed = Zeroizing::new(vec![0; 32]);
      rng.fill_bytes(&mut seed);
    }
    repr.as_mut().zeroize();

    res
  }
```

**File:** crypto/ciphersuite/kp256/src/lib.rs (L87-89)
```rust
        // Zeroize the temp values we can due to the possibility hash_to_F is being used for nonces
        wide.zeroize();
        array.zeroize();
```
