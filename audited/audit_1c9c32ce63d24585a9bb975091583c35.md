### Title
Transaction Substitution via Unvalidated Chain Context in Bitcoin RPC get_transaction()

### Summary
The `get_transaction()` function validates only that the returned transaction's computed txid matches the requested hash, but does not verify which block, chain, or confirmation status the transaction has. This allows malicious Bitcoin RPC nodes or mempool transactions to cause validators to falsely mark transactions as complete, permanently preventing them from participating in threshold signing attempts and potentially causing transaction execution failures if sufficient validators are affected.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**
The `get_transaction()` function calls Bitcoin RPC's `getrawtransaction` with only the transaction ID parameter, without specifying a block hash or requesting verbose output that includes confirmation status. It validates only that the returned transaction's computed txid matches the requested hash, but performs no validation of:
- Which block contains the transaction
- Whether the block is on the canonical Bitcoin chain
- Whether the transaction is confirmed or merely in the mempool
- Which network the transaction is from (mainnet vs testnet vs forks)

**Critical Usage in confirm_completion():** [2](#0-1) 

When a validator claims an eventuality completion, other validators verify this claim by calling `confirm_completion()`, which directly uses `get_transaction()` without any additional block or chain validation.

**Permanent Impact on Signing Participation:** [3](#0-2) 

When `confirm_completion()` succeeds, the validator saves the completion to `CompletionsDb` and stops all signing attempts for that transaction.

**Refusal to Participate in Reattempts:** [4](#0-3) 

Once marked complete in `CompletionsDb`, the validator permanently refuses to participate in any future signing attempts for that transaction, even if it was never actually confirmed on the canonical Bitcoin chain.

**Why Existing Mitigations Fail:**
The scanner's `get_eventuality_completions()` uses actual block data and is safe: [5](#0-4) 

However, the scanner's authoritative detection does not override false completions recorded via `confirm_completion()`. Both paths write to the same `CompletionsDb`, and once a validator marks a transaction complete (even falsely), they never participate in signing it again.

### Impact Explanation

**Critical Invariant Violated:**
This vulnerability violates Critical Invariant #4 (Batch correctness) and falls under the "Reportedly received funds which were not actually received/spendable" critical scope.

**Specific Harm:**
1. **Threshold Signing Failure**: If ≥34% of validators (the minimum required to prevent threshold signing with t = n * 2/3 + 1) falsely mark a transaction as complete, the transaction can never be successfully signed and published to the canonical Bitcoin chain.

2. **Permanent Fund Lock**: Burns (withdrawals) that should execute on Bitcoin would fail permanently, preventing users from withdrawing their funds from Serai.

3. **Batch Execution Failure**: Forward transactions during multisig rotation would fail to execute: [6](#0-5) 

This could prevent multisig rotation from completing, potentially causing all eventualities to remain unresolved and breaking the 6-hour rotation requirement.

**Quantified Impact:**
- Asset at risk: All Bitcoin-backed sriXYZ tokens held by affected users
- Affected parties: Any user attempting to burn/withdraw Bitcoin during the attack period
- System availability: Complete halt of Bitcoin withdrawal operations until manual intervention

### Likelihood Explanation

**Attack Scenario 1 - Mempool Transaction (High Likelihood):**
Bitcoin Core's `getrawtransaction` returns transactions from the mempool when called without a block hash parameter. An attacker can:
1. Broadcast a transaction to Bitcoin mempool
2. Have a confederate validator claim completion immediately
3. Other validators call `confirm_completion()` → `get_transaction()` which returns the mempool transaction
4. Validators mark it complete before it's actually confirmed
5. Transaction is then replaced (RBF), dropped from mempool, or never confirms due to low fees

**Attack Prerequisites:**
- Control of one validator (to broadcast false completion claim)
- Standard Bitcoin node operation (honest nodes return mempool transactions)

**Attack Scenario 2 - Malicious RPC Node (Medium Likelihood):**
If an attacker controls or compromises the Bitcoin RPC endpoint used by validators:
1. Return transactions from testnet, forks, or orphaned blocks with matching txid
2. Validators mark transactions complete when they don't exist on canonical mainnet

**Attack Prerequisites:**
- Compromise of validator infrastructure OR
- Man-in-the-middle attack on RPC connections OR
- DNS poisoning/BGP hijacking to redirect RPC endpoints

**Economic Feasibility:**
- Cost: Minimal (broadcasting transactions to mempool is free; RPC compromise varies)
- Gain: Can prevent legitimate withdrawals, potentially front-running or griefing high-value operations
- Detection: Low risk - false completions appear as normal protocol operation until signing fails

### Recommendation

**Primary Fix - Validate Block and Confirmations:**
Modify `get_transaction()` to request verbose output including block hash and confirmations:

```rust
pub async fn get_transaction(&self, hash: &[u8; 32]) -> Result<(Transaction, Option<[u8; 32]>), RpcError>
```

Call `getrawtransaction` with verbose=true to receive block hash, then validate:
1. Transaction is included in a block (not just mempool)
2. Block exists on the canonical chain via `get_block_number()`
3. Block has sufficient confirmations

**Alternative for confirm_completion():**
Since `confirm_completion()` is only an optimization to stop signing attempts faster, require the claim to include the block hash: [2](#0-1) 

Modify to validate the transaction exists in the claimed block and the block is on the canonical chain with sufficient confirmations.

**Testing Recommendations:**
1. Test `confirm_completion()` with mempool transactions (should reject)
2. Test with transactions from orphaned blocks (should reject)
3. Test with transactions from wrong network (testnet) with matching txid (should reject)
4. Verify scanner's `get_eventuality_completions()` remains authoritative

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Validator Alice is signing Bitcoin transaction T with txid `0xABC...`

2. **Attack**: Adversarial validator Bob broadcasts T to Bitcoin mempool (unconfirmed)

3. **False Claim**: Bob sends `ProcessorMessage::Completed` with txid `0xABC...` [7](#0-6) 

4. **Coordinator Broadcast**: Coordinator creates `Transaction::SignCompleted` and broadcasts to all validators [8](#0-7) 

5. **False Verification**: Alice's processor receives `CoordinatorMessage::Completed`, calls `claimed_eventuality_completion()` → `confirm_completion()` → `get_transaction(0xABC...)`

6. **Mempool Return**: Alice's honest Bitcoin node returns the mempool transaction T with matching txid

7. **Validation Passes**: Line 220-221 check passes (txid matches) [9](#0-8) 

8. **False Completion**: Alice marks T as complete in `CompletionsDb` [10](#0-9) 

9. **Transaction Replacement**: Bob uses RBF to replace T with conflicting transaction T' in mempool

10. **Signing Failure**: When coordinator triggers reattempt, Alice refuses to participate [11](#0-10) 

11. **Permanent Lock**: If ≥34% of validators are affected, threshold signing never succeeds, T never confirms on canonical chain, and funds remain locked.

**Expected vs Actual Behavior:**
- **Expected**: Only transactions confirmed on canonical Bitcoin chain with CONFIRMATIONS blocks should be marked complete [12](#0-11) 
- **Actual**: Mempool transactions and transactions from non-canonical chains can be marked complete, causing permanent signing failures

### Citations

**File:** networks/bitcoin/src/rpc.rs (L210-225)
```rust
  /// Get a transaction by its hash.
  pub async fn get_transaction(&self, hash: &[u8; 32]) -> Result<Transaction, RpcError> {
    let hex = self.rpc_call::<String>("getrawtransaction", json!([hex::encode(hash)])).await?;
    let bytes: Vec<u8> = FromHex::from_hex(&hex)
      .map_err(|_| RpcError::InvalidResponse("node didn't use hex to encode the transaction"))?;
    let tx: Transaction = encode::deserialize(&bytes)
      .map_err(|_| RpcError::InvalidResponse("node sent an improperly serialized transaction"))?;

    let mut tx_hash = *tx.compute_txid().as_raw_hash().as_byte_array();
    tx_hash.reverse();
    if hash != &tx_hash {
      Err(RpcError::InvalidResponse("node replied with a different transaction"))?;
    }

    Ok(tx)
  }
```

**File:** processor/src/networks/bitcoin.rs (L742-801)
```rust
  async fn get_eventuality_completions(
    &self,
    eventualities: &mut EventualitiesTracker<Eventuality>,
    block: &Self::Block,
  ) -> HashMap<[u8; 32], (usize, [u8; 32], Transaction)> {
    let mut res = HashMap::new();
    if eventualities.map.is_empty() {
      return res;
    }

    fn check_block(
      eventualities: &mut EventualitiesTracker<Eventuality>,
      block: &Block,
      res: &mut HashMap<[u8; 32], (usize, [u8; 32], Transaction)>,
    ) {
      for tx in &block.txdata[1 ..] {
        if let Some((plan, _)) = eventualities.map.remove(tx.id().as_slice()) {
          res.insert(plan, (eventualities.block_number, tx.id(), tx.clone()));
        }
      }

      eventualities.block_number += 1;
    }

    let this_block_hash = block.id();
    let this_block_num = (async {
      loop {
        match self.rpc.get_block_number(&this_block_hash).await {
          Ok(number) => return number,
          Err(e) => {
            log::error!("couldn't get the block number for {}: {}", hex::encode(this_block_hash), e)
          }
        }
        sleep(Duration::from_secs(60)).await;
      }
    })
    .await;

    for block_num in (eventualities.block_number + 1) .. this_block_num {
      let block = {
        let mut block;
        while {
          block = self.get_block(block_num).await;
          block.is_err()
        } {
          log::error!("couldn't get block {}: {}", block_num, block.err().unwrap());
          sleep(Duration::from_secs(60)).await;
        }
        block.unwrap()
      };

      check_block(eventualities, &block, &mut res);
    }

    // Also check the current block
    check_block(eventualities, block, &mut res);
    assert_eq!(eventualities.block_number, this_block_num);

    res
  }
```

**File:** processor/src/networks/bitcoin.rs (L855-863)
```rust
  async fn confirm_completion(
    &self,
    eventuality: &Self::Eventuality,
    _: &EmptyClaim,
  ) -> Result<Option<Transaction>, NetworkError> {
    Ok(Some(
      self.rpc.get_transaction(&eventuality.0).await.map_err(|_| NetworkError::ConnectionError)?,
    ))
  }
```

**File:** processor/src/signer.rs (L285-285)
```rust
    ProcessorMessage::Completed { session: self.session, id, tx: claim.as_ref().to_vec() }
```

**File:** processor/src/signer.rs (L311-333)
```rust
  async fn claimed_eventuality_completion(
    &mut self,
    txn: &mut D::Transaction<'_>,
    id: [u8; 32],
    claim: &<N::Eventuality as Eventuality>::Claim,
  ) -> Option<ProcessorMessage> {
    if let Some(eventuality) = EventualityDb::eventuality::<N>(txn, id) {
      match self.network.confirm_completion(&eventuality, claim).await {
        Ok(Some(completion)) => {
          info!(
            "signer eventuality for {} resolved in {}",
            hex::encode(id),
            hex::encode(claim.as_ref())
          );

          let first_completion = !Self::already_completed(txn, id);

          // Save this completion to the DB
          CompletionsDb::complete::<N>(txn, id, &completion);

          if first_completion {
            return Some(self.complete(id, claim));
          }
```

**File:** processor/src/signer.rs (L365-373)
```rust
  async fn attempt(
    &mut self,
    txn: &mut D::Transaction<'_>,
    id: [u8; 32],
    attempt: u32,
  ) -> Option<ProcessorMessage> {
    if Self::already_completed(txn, id) {
      return None;
    }
```

**File:** processor/src/signer.rs (L634-651)
```rust
      CoordinatorMessage::Completed { session: _, id, tx: mut claim_vec } => {
        let mut claim = <N::Eventuality as Eventuality>::Claim::default();
        if claim.as_ref().len() != claim_vec.len() {
          let true_len = claim_vec.len();
          claim_vec.truncate(2 * claim.as_ref().len());
          warn!(
            "a validator claimed {}... (actual length {}) completed {} yet {}",
            hex::encode(&claim_vec),
            true_len,
            hex::encode(id),
            "that's not a valid Claim",
          );
          return None;
        }
        claim.as_mut().copy_from_slice(&claim_vec);

        self.claimed_eventuality_completion(txn, id, &claim).await
      }
```

**File:** spec/processor/Multisig Rotation.md (L117-127)
```markdown
6) Once the 6 hour period has expired, the prior multisig stops handling outputs
   it didn't itself create. Any remaining `Eventuality`s are completed, and any
   available/freshly available outputs are forwarded (creating new
   `Eventuality`s which also need to successfully resolve).

   Once all the 6 hour period has expired, no `Eventuality`s remain, and all
   outputs are forwarded, the multisig publishes a final `Batch` of the first
   block, plus `CONFIRMATIONS`, which met these conditions, regardless of if it
   would've otherwise had a `Batch`. No further actions by it, nor its
   validators, are expected (unless, of course, those validators remain present
   in the new multisig).
```

**File:** spec/processor/Scanning.md (L1-6)
```markdown
# Scanning

Only blocks with finality, either actual or sufficiently probabilistic, are
operated upon. This is referred to as a block with `CONFIRMATIONS`
confirmations, the block itself being the first confirmation.

```
