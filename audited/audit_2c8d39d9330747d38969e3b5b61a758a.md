### Title
Missing Economic Security Enforcement Before Batch Signing Causes Irreversible Loss of User Deposits

### Summary
The system allows validators to sign batches containing deposit instructions even when economic security thresholds are not met, causing on-chain mint operations to fail while leaving user deposits permanently locked in the multisig. No recovery mechanism exists to refund users when `InstructionFailure` events occur due to insufficient economic security.

### Finding Description

The `Curve::CONTEXT` trait constant is a cryptographic identifier unrelated to economic security checks. [1](#0-0) 

Batch signing proceeds without economic security validation. The processor's `BatchSigner::sign()` method only checks if a batch was previously completed, not whether economic security is sufficient. [2](#0-1) 

The coordinator's substrate signing handler verifies DKG key completion but not economic security status before processing signing data. [3](#0-2) 

Economic security checks occur only at mint time via `AllowMint::is_allowed()`, which compares total allocated stake against required stake for the balance being minted. [4](#0-3) 

When batches execute on-chain, individual instruction failures are handled transactionally with `InstructionFailure` events emitted, but batch processing continues. [5](#0-4) 

The coordinator only processes `Batch` events from Serai, not `InstructionFailure` events. [6](#0-5) [7](#0-6) 

The refund mechanism only handles processor-side instruction parsing failures before reaching Serai, not on-chain execution failures. [8](#0-7) 

### Impact Explanation

Users who deposit external assets (Bitcoin, Ethereum, Monero) when economic security is insufficient will permanently lose access to their funds. The deposits are controlled by validators' threshold signatures, but the corresponding sriXYZ tokens cannot be minted due to `Error::MintNotAllowed`. [9](#0-8) 

The required stake formula is `(COIN_VALUE * 1.5) + 20% margin`, meaning all deposits before the `EconomicSecurityReached` event are vulnerable. [10](#0-9) 

This directly violates Critical Invariant #5: "minted sriXYZ equals verified external deposits" and meets the Critical scope: "Reportedly received funds which were not actually received/spendable."

### Likelihood Explanation

This occurs naturally during the "Pre-Economic Security" era of any external network integration. No attacker is required—the vulnerability triggers through normal protocol operation when users deposit before validators achieve sufficient stake allocation.

The economic security pallet tracks this state per network. [11](#0-10) 

Detection is trivial via `InstructionFailure` events in block explorers, but no automated recovery mechanism exists.

### Recommendation

Add economic security validation before batch signing in the processor's `sign()` method by querying the Serai chain for `EconomicSecurityBlock` status and rejecting signing attempts for networks without sufficient security.

Implement `InstructionFailure` event handlers in the coordinator to extract failed instructions with origin addresses and create refund plans back to the original depositors.

Add `instruction_failure_events()` to the Serai client to filter for `InstructionFailure` events alongside existing `Batch` event processing.

Alternatively, prevent batch creation entirely before economic security is reached, or implement an on-chain refund queue for failed instructions.

### Proof of Concept

1. Initialize Serai network with 50,000 SRI validator stake for Bitcoin network
2. User deposits 1 BTC (~$40,000) to multisig address controlled by validators
3. Processor scans block and creates `Batch` with `Transfer` instruction containing deposit
4. Validators execute FROST signing protocol—no economic security check blocks this
5. Signed batch submitted to Serai via `execute_batch`
6. On-chain execution calls `Coins::mint()` for 1 BTC worth of sriBTC
7. `AllowMint::is_allowed()` calculates required stake: `(40000 * 1.5) + (40000 * 0.2) = 68,000 SRI equivalent`
8. Check fails: `50,000 < 68,000`, returns false
9. Mint fails with `Error::MintNotAllowed`
10. `InstructionFailure` event emitted at index 0
11. Coordinator ignores event—no handler implemented
12. User's 1 BTC remains in multisig, user receives 0 sriBTC
13. No refund plan created—funds permanently inaccessible

Expected: Signing prevented OR automatic refund created
Actual: Signing proceeds, instruction fails, no recovery, permanent fund loss

### Citations

**File:** crypto/frost/src/curve/mod.rs (L44-46)
```rust
pub trait Curve: Ciphersuite {
  /// Context string for this curve.
  const CONTEXT: &'static [u8];
```

**File:** processor/src/batch_signer.rs (L192-203)
```rust
  pub fn sign(&mut self, txn: &mut D::Transaction<'_>, batch: Batch) -> Option<ProcessorMessage> {
    debug_assert_eq!(self.network, batch.network);
    let id = batch.id;
    if CompletedDb::get(txn, id).is_some() {
      debug!("Sign batch order for ID we've already completed signing");
      // See batch_signed for commentary on why this simply returns
      return None;
    }

    self.signable.insert(id, batch);
    self.attempt(txn, id, 0)
  }
```

**File:** coordinator/src/tributary/handle.rs (L621-632)
```rust
      Transaction::SubstrateSign(data) => {
        // Provided transactions ensure synchrony on any signing protocol, and we won't start
        // signing with threshold keys before we've confirmed them on-chain
        let Some(removed) =
          crate::tributary::removed_as_of_set_keys(self.txn, self.spec.set(), genesis)
        else {
          self.fatal_slash(
            data.signed.signer.to_bytes(),
            "signing despite not having set keys on substrate",
          );
          return;
        };
```

**File:** substrate/validator-sets/pallet/src/lib.rs (L850-853)
```rust
      // required stake formula (COIN_VALUE * 1.5) + margin(20%)
      let required_stake = total_coin_value.saturating_mul(3).saturating_div(2);
      required_stake.saturating_add(total_coin_value.saturating_div(5))
    }
```

**File:** substrate/validator-sets/pallet/src/lib.rs (L1185-1196)
```rust
  impl<T: Config> AllowMint for Pallet<T> {
    fn is_allowed(balance: &ExternalBalance) -> bool {
      // get the required stake
      let current_required = Self::required_stake_for_network(balance.coin.network());
      let new_required = current_required + Self::required_stake(balance);

      // get the total stake for the network & compare.
      let staked =
        Self::total_allocated_stake(NetworkId::from(balance.coin.network())).unwrap_or(Amount(0));
      staked.0 >= new_required
    }
  }
```

**File:** substrate/in-instructions/pallet/src/lib.rs (L276-284)
```rust
      for (i, instruction) in batch.instructions.into_iter().enumerate() {
        if Self::execute(instruction).is_err() {
          Self::deposit_event(Event::InstructionFailure {
            network: batch.network,
            id: batch.id,
            index: u32::try_from(i).unwrap(),
          });
        }
      }
```

**File:** coordinator/src/substrate/mod.rs (L142-158)
```rust
  for batch in serai.in_instructions().batch_events().await? {
    if let InInstructionsEvent::Batch { network, id, block: network_block, instructions_hash } =
      batch
    {
      network_had_event(&mut burns, &mut batches, network);

      BatchInstructionsHashDb::set(txn, network, id, &instructions_hash);

      // Make sure this is the only Batch event for this network in this Block
      assert!(batch_block.insert(network, network_block).is_none());

      // Add the batch included by this block
      batches.get_mut(&network).unwrap().push(id);
    } else {
      panic!("Batch event wasn't Batch: {batch:?}");
    }
  }
```

**File:** substrate/client/src/serai/in_instructions.rs (L30-45)
```rust
  pub async fn batch_events(&self) -> Result<Vec<InInstructionsEvent>, SeraiError> {
    self
      .0
      .events(|event| {
        if let serai_abi::Event::InInstructions(event) = event {
          if matches!(event, InInstructionsEvent::Batch { .. }) {
            Some(event.clone())
          } else {
            None
          }
        } else {
          None
        }
      })
      .await
  }
```

**File:** processor/src/multisigs/mod.rs (L344-353)
```rust
  fn refund_plan(
    scheduler: &mut N::Scheduler,
    txn: &mut D::Transaction<'_>,
    output: N::Output,
    refund_to: N::Address,
  ) -> Plan<N> {
    log::info!("creating refund plan for {}", hex::encode(output.id()));
    assert_eq!(output.kind(), OutputType::External);
    scheduler.refund_plan::<D>(txn, output, refund_to)
  }
```

**File:** substrate/coins/pallet/src/lib.rs (L166-174)
```rust
    pub fn mint(to: Public, balance: Balance) -> Result<(), Error<T, I>> {
      // If the coin isn't Serai, which we're always allowed to mint, and the mint isn't explicitly
      // allowed, error
      if !ExternalCoin::try_from(balance.coin)
        .map(|coin| T::AllowMint::is_allowed(&ExternalBalance { coin, amount: balance.amount }))
        .unwrap_or(true)
      {
        Err(Error::<T, I>::MintNotAllowed)?;
      }
```

**File:** substrate/economic-security/pallet/src/lib.rs (L38-51)
```rust
    fn on_initialize(n: BlockNumberFor<T>) -> Weight {
      // we accept we reached economic security once we can mint smallest amount of a network's coin
      for coin in EXTERNAL_COINS {
        let existing = EconomicSecurityBlock::<T>::get(coin.network());
        // TODO: we don't need to check for oracle value if is_allowed returns false when there is
        // no coin value
        if existing.is_none() &&
          Dex::<T>::security_oracle_value(coin).is_some() &&
          <T as CoinsConfig>::AllowMint::is_allowed(&ExternalBalance { coin, amount: Amount(1) })
        {
          EconomicSecurityBlock::<T>::set(coin.network(), Some(n));
          Self::deposit_event(Event::EconomicSecurityReached { network: coin.network() });
        }
      }
```
