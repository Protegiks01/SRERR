### Title
Missing Merkle Root Validation in Bitcoin Block Retrieval Enables Malicious RPC Node to Inject Fake Transactions

### Summary
The `get_block()` function in the Bitcoin RPC client validates block hashes but does not verify that the merkle root in the block header matches the included transactions. A compromised or malicious Bitcoin RPC node can provide blocks with valid headers but fake transaction sets, causing the processor to mint sriXYZ for non-existent deposits or miss real deposits, violating the mint/burn accounting invariant.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `get_block()` function performs only block hash validation to ensure the returned block matches the requested hash. However, it does not validate that the merkle root field in the block header actually corresponds to the merkle tree computed from the included transactions.

**Root Cause:**
The function deserializes the block using the bitcoin library's consensus decoder, which parses the data structure but does not perform cryptographic validation of the merkle root. The only validation performed is: [2](#0-1) 

This validation only ensures the block's hash (computed from the header) matches the requested hash. Since the merkle root is a field within the header, a malicious node can provide a block header with a valid merkle_root field value and correct proof-of-work, but include a completely different set of transactions than what the merkle root commits to.

**Why Existing Mitigations Fail:**
The codebase documentation confirms the processor fully trusts the connected Bitcoin RPC node without independent validation. As shown in the Network Scanning documentation, there is no SPV-style verification of merkle proofs or consensus rules—all blockchain validation is delegated to the RPC node.

**Critical Usage Context:**
The processor uses `get_block()` to scan for deposits and validate transaction completions: [3](#0-2) 

The retrieved block is then used to scan transactions for outputs to the multisig address: [4](#0-3) 

### Impact Explanation

**Specific Harm:**
A compromised Bitcoin RPC node can exploit this vulnerability to:

1. **Inject Fake Deposits**: Provide blocks containing fake transactions that appear to send funds to Serai's multisig address. The processor would detect these as valid deposits, trigger batch signing, and cause Serai to mint sriXYZ tokens without any real Bitcoin being received. This directly violates Critical Invariant #5: "minted sriXYZ equals verified external deposits."

2. **Hide Real Deposits**: Exclude genuine deposit transactions from blocks while keeping the valid header. Users' funds would be locked on Bitcoin without receiving corresponding sriXYZ on Serai, causing fund loss and denial of service.

3. **Fake Eventuality Completions**: Report that outbound transactions (burns) have been confirmed when they haven't, causing the coordinator to mark plans as complete prematurely.

**Quantified Impact:**
- Unlimited minting of sriXYZ (up to the total value locked in Bitcoin multisig)
- Complete denial of service for Bitcoin deposits
- Loss of all user funds attempting Bitcoin deposits
- Insolvency of the Serai Bitcoin bridge

**Severity Justification:**
This is a **HIGH** severity vulnerability under the protocol scope: "Incorrect/incomplete cryptographic formulae within a verifier's callstack." The merkle root verification is a fundamental cryptographic verification that's completely missing from the block validation logic, which is in the verifier's callstack for external deposits. It also enables "Reportedly received funds which were not actually received/spendable" (Critical scope).

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control or compromise of the Bitcoin RPC node that the processor connects to
- Ability to generate valid Bitcoin block headers (requires knowing a valid merkle root to include in the header, but can source this from real blocks)
- Ability to serve modified block data via RPC

**Attack Complexity:**
The attack is straightforward:
1. Obtain a valid Bitcoin block header from the real blockchain
2. Construct fake transactions that send BTC to Serai's multisig address (or exclude real ones)
3. Serve the valid header with fake transactions when the processor calls `getblock`
4. The processor validates only the block hash (header-based), not the merkle tree
5. Fake transactions are processed as real deposits

**Economic Feasibility:**
- Running a malicious Bitcoin RPC node costs minimal resources
- Processors must connect to external Bitcoin infrastructure, creating the attack surface
- No on-chain cost to the attacker; all manipulation happens at the RPC layer
- Potential gain: unlimited minting of sriXYZ or theft of all deposited Bitcoin

**Detection Risk:**
- The attack is difficult to detect unless validators cross-reference multiple independent Bitcoin nodes
- No on-chain evidence of manipulation (fake transactions never appear on the real Bitcoin blockchain)
- The processor's logs would show "valid" blocks being processed

**Operational Constraints:**
Processors are designed to connect to a single Bitcoin RPC endpoint per configuration, making this a single point of failure without additional validation layers.

### Recommendation

**Primary Fix - Add Merkle Root Validation:**

Implement merkle root validation in `get_block()` to verify that the header's merkle root matches the computed merkle tree of included transactions:

```rust
pub async fn get_block(&self, hash: &[u8; 32]) -> Result<Block, RpcError> {
  // ... existing code ...
  
  // Validate merkle root matches transactions
  let computed_merkle_root = compute_merkle_root(&block.txdata);
  if block.header.merkle_root != computed_merkle_root {
    Err(RpcError::InvalidResponse("merkle root does not match transactions"))?;
  }
  
  // ... existing hash validation ...
  
  Ok(block)
}

fn compute_merkle_root(txdata: &[Transaction]) -> TxMerkleNode {
  // Implement Bitcoin's merkle tree algorithm:
  // 1. Compute txids for all transactions
  // 2. Build merkle tree by hashing pairs
  // 3. Return root hash
}
```

**Alternative Mitigation - Multi-Node Consensus:**

If adding merkle validation is not immediately feasible:
1. Connect to multiple independent Bitcoin RPC nodes
2. Fetch blocks from all nodes and compare responses
3. Reject blocks if responses don't match across majority of nodes
4. Alert operators if discrepancies are detected

**Testing Recommendations:**
1. Create unit tests that verify merkle root validation rejects blocks with mismatched merkle roots
2. Create integration tests with a mock malicious RPC node that serves blocks with fake transactions
3. Verify the processor correctly rejects such blocks and logs appropriate errors
4. Test that genuine blocks with valid merkle roots still process correctly

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup Malicious RPC Node:**
   - Clone Bitcoin Core or create RPC wrapper
   - Intercept `getblock` RPC calls
   - Maintain connection to real Bitcoin network for other calls

2. **Create Fake Block:**
   ```
   real_block = fetch_from_real_bitcoin_network(block_hash)
   header = real_block.header  // Keep valid header with correct merkle_root
   
   fake_tx = create_transaction_to_serai_multisig(amount=1000_BTC)
   fake_block = Block {
     header: header,  // Valid header with valid PoW
     txdata: [real_block.txdata[0], fake_tx]  // Coinbase + fake deposit
   }
   ```

3. **Serve to Processor:**
   ```
   When processor calls getblock(block_hash, 0):
     Return serialize(fake_block)
   ```

4. **Expected Behavior (Vulnerable Code):**
   - Processor validates: `block.block_hash() == requested_hash` ✓ (passes - header is valid)
   - Processor scans transactions and finds fake deposit
   - Processor creates batch with fake deposit
   - Serai mints 1000 sriBTC without receiving any real Bitcoin

5. **Expected Behavior (After Fix):**
   - Processor validates block hash ✓
   - Processor validates: `compute_merkle_root(txdata) == header.merkle_root` ✗ (fails)
   - Processor rejects block with error
   - No fake deposit is processed

**Realistic Parameter Values:**
- Target: Any Bitcoin block after processor activation
- Fake deposit amount: Any value (attacker limited only by believability)
- Cost to attacker: $0 (no on-chain cost)
- Profit to attacker: Unlimited sriXYZ minting

### Citations

**File:** networks/bitcoin/src/rpc.rs (L172-186)
```rust
  pub async fn get_block(&self, hash: &[u8; 32]) -> Result<Block, RpcError> {
    let hex = self.rpc_call::<String>("getblock", json!([hex::encode(hash), 0])).await?;
    let bytes: Vec<u8> = FromHex::from_hex(&hex)
      .map_err(|_| RpcError::InvalidResponse("node didn't use hex to encode the block"))?;
    let block: Block = encode::deserialize(&bytes)
      .map_err(|_| RpcError::InvalidResponse("node sent an improperly serialized block"))?;

    let mut block_hash = *block.block_hash().as_raw_hash().as_byte_array();
    block_hash.reverse();
    if hash != &block_hash {
      Err(RpcError::InvalidResponse("node replied with a different block"))?;
    }

    Ok(block)
  }
```

**File:** processor/src/networks/bitcoin.rs (L680-684)
```rust
  async fn get_block(&self, number: usize) -> Result<Self::Block, NetworkError> {
    let block_hash =
      self.rpc.get_block_hash(number).await.map_err(|_| NetworkError::ConnectionError)?;
    self.rpc.get_block(&block_hash).await.map_err(|_| NetworkError::ConnectionError)
  }
```

**File:** processor/src/networks/bitcoin.rs (L686-740)
```rust
  async fn get_outputs(&self, block: &Self::Block, key: ProjectivePoint) -> Vec<Output> {
    let (scanner, _, kinds) = scanner(key);

    let mut outputs = vec![];
    // Skip the coinbase transaction which is burdened by maturity
    for tx in &block.txdata[1 ..] {
      for output in scanner.scan_transaction(tx) {
        let offset_repr = output.offset().to_repr();
        let offset_repr_ref: &[u8] = offset_repr.as_ref();
        let kind = kinds[offset_repr_ref];

        let output = Output { kind, presumed_origin: None, output, data: vec![] };
        assert_eq!(output.tx_id(), tx.id());
        outputs.push(output);
      }

      if outputs.is_empty() {
        continue;
      }

      // populate the outputs with the origin and data
      let presumed_origin = {
        // This may identify the P2WSH output *embedding the InInstruction* as the origin, which
        // would be a bit trickier to spend that a traditional output...
        // There's no risk of the InInstruction going missing as it'd already be on-chain though
        // We *could* parse out the script *without the InInstruction prefix* and declare that the
        // origin
        // TODO
        let spent_output = {
          let input = &tx.input[0];
          let mut spent_tx = input.previous_output.txid.as_raw_hash().to_byte_array();
          spent_tx.reverse();
          let mut tx;
          while {
            tx = self.rpc.get_transaction(&spent_tx).await;
            tx.is_err()
          } {
            log::error!("couldn't get transaction from bitcoin node: {tx:?}");
            sleep(Duration::from_secs(5)).await;
          }
          tx.unwrap().output.swap_remove(usize::try_from(input.previous_output.vout).unwrap())
        };
        Address::new(spent_output.script_pubkey)
      };
      let data = Self::extract_serai_data(tx);
      for output in &mut outputs {
        if output.kind == OutputType::External {
          output.data.clone_from(&data);
        }
        output.presumed_origin.clone_from(&presumed_origin);
      }
    }

    outputs
  }
```
