### Title
FROST Binding Factor Double-Hashing in Production Transcripts

### Summary
The FROST binding factor derivation in `nonce.rs:169` incorrectly applies `hash_binding_factor` (H1) to already-hashed transcript challenge outputs when using production transcript types (DigestTranscript/RecommendedTranscript), resulting in double-hashing that deviates from the IETF FROST specification. While IETF test vectors pass because they use IetfTranscript (which returns raw data), production signatures use an incorrect cryptographic formula that prevents interoperability with IETF-compliant FROST implementations.

### Finding Description

The binding factor calculation occurs at two critical points: [1](#0-0) [2](#0-1) 

The IETF FROST specification requires binding factors to be computed as:
```
rho_i = H1(group_key || H4(msg) || H5(commitments) || encode(i))
```

Where H1, H4, and H5 are single hash operations on their respective inputs.

However, the code creates a rho_transcript and calls `transcript.challenge(b"rho")` before passing the result to `hash_binding_factor` (H1). The behavior differs critically based on transcript type:

**With IetfTranscript (test vectors only):** [3](#0-2) 

The `challenge()` method returns raw concatenated bytes, so H1 is applied correctly to raw data.

**With DigestTranscript/RecommendedTranscript (production):** [4](#0-3) 

The `challenge()` method finalizes and returns a hash digest, so H1 is applied to already-hashed data, resulting in double-hashing.

Production code uses RecommendedTranscript: [5](#0-4) [6](#0-5) 

The test vectors do not validate binding_factor values, only final signatures: [7](#0-6) 

This allows the bug to go undetected since all participants compute the same (incorrect) binding factor consistently, producing valid signatures within the closed system.

### Impact Explanation

**Scope Classification:** HIGH - "Incorrect/incomplete cryptographic formulae within a verifier's callstack"

The binding factor is used in signature share verification: [8](#0-7) 

**Concrete Impacts:**

1. **IETF Specification Non-Conformance**: Production FROST signatures deviate from the published IETF draft-irtf-cfrg-frost-11 specification, which Serai claims to implement. [9](#0-8) 

2. **Interoperability Failure**: Cannot interoperate with other IETF-compliant FROST implementations. If Serai attempts cross-implementation signing, binding factors will differ, causing signature verification failures or potential security inconsistencies.

3. **Transcript Binding Violation**: Critical Invariant #3 states "challenges bind to all required context; no collision or ambiguity in transcripted data." The double-hashing creates a different collision space than specified, potentially enabling unintended transcript collisions.

4. **Unvalidated Intermediate Values**: Test vectors contain binding_factor_input and binding_factor fields that are never validated, masking the deviation from the specification.

### Likelihood Explanation

**Probability:** 100% - occurs in all production signing operations using non-IETF transcripts.

**Attack Prerequisites:**
- Attacker attempts to interoperate Serai's FROST implementation with another IETF-compliant implementation
- Or exploits transcript collision properties unique to the double-hashed version

**Exploitation Complexity:** Low
- The issue manifests automatically in production without any specific attack
- Interoperability attempts will immediately reveal incompatibility

**Economic Feasibility:** Not directly exploitable for economic gain in current closed system, but creates interoperability and upgrade risks.

**Detection:** Currently undetected because:
1. All Serai participants use the same incorrect formula
2. Test vectors only validate final signatures, not intermediate binding factors
3. No cross-implementation testing occurs

### Recommendation

**Immediate Fix:**

Modify the binding factor calculation to extract raw serialized data instead of hashed challenge:

In `sign.rs`, replace the rho_transcript approach with direct serialization:
```rust
// Construct raw rho_input per IETF spec
let mut rho_input = Vec::new();
rho_input.extend(self.params.keys.group_key().to_bytes().as_ref());
rho_input.extend(C::hash_msg(msg).as_ref());

// Collect and hash commitments directly
let mut commitments_bytes = Vec::new();
for l in &included {
  let binding = &B.0[l];
  binding.commitments.write(&mut commitments_bytes).unwrap();
}
rho_input.extend(C::hash_commitments(&commitments_bytes).as_ref());

// In calculate_binding_factors, append participant ID and apply H1 once
rho_input.extend(C::F::from(u64::from(u16::from(l))).to_repr().as_ref());
let binding_factor = C::hash_binding_factor(&rho_input);
```

**Alternative:** Create a transcript method that extracts raw serialized data without finalization.

**Testing Recommendations:**
1. Add explicit validation of binding_factor values from IETF test vectors
2. Test interoperability with reference IETF FROST implementations
3. Add assertions comparing IetfTranscript and RecommendedTranscript binding factor computation to ensure consistency

### Proof of Concept

**Expected Behavior (IETF Spec):**
```
rho_input = group_key || H4(msg) || H5(commitments) || encode(participant)
rho = H1(rho_input)
[Single hash with H1]
```

**Actual Behavior with IetfTranscript (tests pass):**
```
transcript.append(group_key, H4(msg), H5(commitments), participant)
challenge = transcript.challenge()  // Returns raw bytes
rho = H1(challenge)  // Correct: H1 applied to raw data
```

**Actual Behavior with DigestTranscript (production bug):**
```
transcript.append(group_key, H4(msg), H5(commitments), participant)
challenge = transcript.challenge()  // Returns Hash(transcript)
rho = H1(challenge)  // WRONG: H1(Hash(data)) = double-hash
```

**Verification:**
Compare binding_factor values from test vectors (e.g., frost-ristretto255-sha512.json) with production-computed values using the same inputs but DigestTranscript instead of IetfTranscript. The values will differ, confirming the double-hashing issue.

The bug is masked in testing because IetfTranscript's challenge() returns raw bytes, but manifests in production where DigestTranscript's challenge() returns a finalized hash, causing an unintended double-hash operation that deviates from the IETF FROST specification.

### Citations

**File:** crypto/frost/src/nonce.rs (L169-169)
```rust
          .map(|_| C::hash_binding_factor(transcript.challenge(b"rho").as_ref()))
```

**File:** crypto/frost/src/sign.rs (L367-367)
```rust
        C::hash_commitments(self.params.algorithm.transcript().challenge(b"preprocesses").as_ref()),
```

**File:** crypto/frost/src/sign.rs (L385-396)
```rust
    let our_binding_factors = B.binding_factors(multisig_params.i());
    let nonces = self
      .nonces
      .drain(..)
      .enumerate()
      .map(|(n, nonces)| {
        let [base, mut actual] = nonces.0;
        *actual *= our_binding_factors[n];
        *actual += base.deref();
        actual
      })
      .collect::<Vec<_>>();
```

**File:** crypto/frost/src/algorithm.rs (L117-119)
```rust
    fn challenge(&mut self, _: &'static [u8]) -> Vec<u8> {
      self.0.clone()
    }
```

**File:** crypto/transcript/src/lib.rs (L125-133)
```rust
  fn challenge(&mut self, label: &'static [u8]) -> Self::Challenge {
    self.append(DigestTranscriptMember::Challenge, label);
    let mut cloned = self.0.clone();

    // Explicitly fork these transcripts to prevent length extension attacks from being possible
    // (at least, without the additional ability to remove a byte from a finalized hash)
    self.0.update([DigestTranscriptMember::Continued.as_u8()]);
    cloned.update([DigestTranscriptMember::Challenged.as_u8()]);
    cloned.finalize()
```

**File:** crypto/transcript/src/lib.rs (L176-177)
```rust
#[cfg(feature = "recommended")]
pub type RecommendedTranscript = DigestTranscript<blake2::Blake2b512>;
```

**File:** networks/ethereum/src/machine.rs (L306-306)
```rust
  machine: AlgorithmMachine<Secp256k1, Schnorr<Secp256k1, RecommendedTranscript, EthereumHram>>,
```

**File:** crypto/frost/src/tests/vectors.rs (L238-238)
```rust
        assert_eq!(share, hex::decode(&vectors.sig_shares[c]).unwrap());
```

**File:** spec/cryptography/FROST.md (L3-4)
```markdown
Serai implements [FROST](https://eprint.iacr.org/2020/852), as specified in
[draft-irtf-cfrg-frost-11](https://datatracker.ietf.org/doc/draft-irtf-cfrg-frost/).
```
