### Title
Nonce Structure Mismatch Enables Incorrect Cryptographic Formula in Group Nonce Computation

### Summary
The FROST signing protocol lacks validation that all participants use the same nonce structure (number of nonces and generators per nonce). When a malicious or buggy participant sends preprocesses with a different structure than expected by honest participants, the group nonce computation binds commitments to incorrect generators, resulting in incorrect cryptographic formulae within the verifier's callstack.

### Finding Description

**Location**: 
- [1](#0-0) 
- [2](#0-1) 
- [3](#0-2) 
- [4](#0-3) 
- [5](#0-4) 

**Root Cause**:
The `Commitments::read()` function uses a `generators` parameter to determine how many nonce commitments to deserialize per nonce, but does not validate that this structure matches what the sender actually created. Each participant uses their local algorithm's `nonces()` method to interpret incoming preprocesses. [6](#0-5) 

When `AlgorithmSignMachine::read_preprocess()` is called, it reads another participant's commitments using the local algorithm's nonce structure: [7](#0-6) 

Later, when computing group nonces in `BindingFactor::nonces()`, the same local structure is used to access all participants' commitments: [5](#0-4) 

If participants A and B use algorithms with different nonce structures, and the byte counts happen to align, deserialization succeeds but B interprets A's commitments with the wrong structure. For example, if A uses `[[G, 2G]]` (1 nonce, 2 generators) but B expects `[[G], [G]]` (2 nonces, 1 generator each), B will read A's commitment to `2G` as if it were a commitment to `G`, causing cryptographically incorrect group nonce computation.

**Why Existing Mitigations Fail**:
The buffer emptiness check in [8](#0-7)  only catches cases where byte counts don't align. When byte counts match (e.g., 1 nonce with 2 generators = 2 nonces with 1 generator each = 4 group elements), the check passes despite structural mismatch. The algorithm's `verify()` function [9](#0-8)  will detect invalid signatures, but cannot identify which participant used a mismatched structure.

### Impact Explanation

**Severity: HIGH** - This qualifies as "Incorrect/incomplete cryptographic formulae within a verifier's callstack" per the audit scope.

The group nonce computation in `BindingFactor::nonces()` is part of the signature verification path. When commitments are bound to incorrect generators due to structure mismatch, the cryptographic formula `D += commitments.nonces[n].generators[g].0[0]` accesses commitments created for generator X but interprets them as commitments for generator Y.

**Specific Harm**:
1. **Protocol Liveness Failure**: Signatures fail verification, halting all signing operations for the affected session
2. **Byzantine Fault Misidentification**: Blame assignment logic in [10](#0-9)  may incorrectly identify honest participants as malicious when the root cause is structural mismatch
3. **Denial of Service**: A single malicious participant can prevent signature completion for all external network operations (Bitcoin, Ethereum, Monero transactions)

**Who Is Affected**: All validators in the signing session, preventing cross-chain transactions and potentially freezing user funds in external multisigs until the issue is resolved.

### Likelihood Explanation

**Likelihood: LOW to MEDIUM**

**Required Attacker Capabilities**:
- Malicious validator with ability to modify their node's code
- OR version mismatch during upgrade deployment
- OR bug in algorithm implementation causing non-deterministic `nonces()` return values

**Attack Complexity**: 
LOW - Attacker only needs to modify their local `Algorithm` implementation to return a different nonce structure with matching byte count (e.g., using the test `MultiNonce` algorithm from [11](#0-10)  instead of the standard `Schnorr` algorithm).

**Economic Feasibility**: 
HIGH - No direct cost to attacker beyond running a validator node. The attack causes DoS rather than fund theft, so attacker gains may be limited to competitive advantage or ransom scenarios.

**Detection Risk**: 
MEDIUM - Signing failures are observable, but identifying the root cause (structure mismatch vs other errors) requires code inspection. The error manifests as `FrostError::InternalError` [12](#0-11)  when all shares appear valid but signature is invalid.

### Recommendation

**Primary Fix**: Add explicit validation in `Commitments::read()` that encodes and validates the nonce structure:

1. Modify `Commitments::write()` to prefix the serialization with structure metadata (number of nonces and generators per nonce)
2. Modify `Commitments::read()` to read and validate this metadata matches the expected `generators` parameter
3. Return an IO error if structures don't match

**Alternative Mitigation**: Add algorithm identifier validation at the protocol level:

1. Include algorithm identifier in the transcript
2. Validate all participants use the same algorithm identifier before processing preprocesses
3. Reject preprocesses from participants with mismatched algorithms

**Testing Recommendations**:
1. Add integration test with participants using `Schnorr` vs `MultiNonce` algorithms
2. Verify deserialization fails with structure mismatch
3. Verify error correctly identifies malicious participant
4. Test byte-count-aligned structure mismatches (e.g., `[[G, 2G]]` vs `[[G], [G]]`)

### Proof of Concept

**Exploitation Algorithm**:

1. **Setup**: Honest participants use `Schnorr` algorithm returning `vec![vec![G]]` (1 nonce, 1 generator)

2. **Malicious Participant** uses custom algorithm:
```
fn nonces(&self) -> Vec<Vec<C::G>> {
  vec![vec![C::generator()]] // Appears normal
}
```
But during preprocessing, manually constructs commitments with different structure internally

3. **Serialization**: Malicious participant crafts preprocess bytes representing structure `[[G, 2G]]` (1 nonce, 2 generators = 4 group elements total)

4. **Deserialization**: Honest participant reads with structure `[[G], [G]]` (2 nonces, 1 generator each = 4 group elements total)
   - Byte count matches (4 elements in both cases)
   - Buffer emptiness check passes
   - Commitments stored with wrong interpretation

5. **Group Nonce Computation**: When honest participant computes group nonces:
   - Accesses `commitments.nonces[0].generators[0]` - gets malicious party's commitment to G (correct)
   - Accesses `commitments.nonces[1].generators[0]` - gets malicious party's commitment to 2G but interprets as commitment to G (WRONG)

6. **Result**: Signature verification fails, blame assignment cannot identify the structural mismatch, protocol halts

**Expected Behavior**: Deserialization should fail with structure validation error

**Actual Behavior**: Deserialization succeeds, cryptographic formula uses wrong generator bindings, signature fails with ambiguous error

### Citations

**File:** crypto/frost/src/nonce.rs (L74-79)
```rust
  fn read<R: Read>(reader: &mut R, generators: &[C::G]) -> io::Result<NonceCommitments<C>> {
    Ok(NonceCommitments {
      generators: (0 .. generators.len())
        .map(|_| GeneratorCommitments::read(reader))
        .collect::<Result<_, _>>()?,
    })
```

**File:** crypto/frost/src/nonce.rs (L133-139)
```rust
  pub(crate) fn read<R: Read>(reader: &mut R, generators: &[Vec<C::G>]) -> io::Result<Self> {
    let nonces = (0 .. generators.len())
      .map(|i| NonceCommitments::read(reader, &generators[i]))
      .collect::<Result<Vec<NonceCommitments<C>>, _>>()?;

    Ok(Commitments { nonces })
  }
```

**File:** crypto/frost/src/nonce.rs (L194-212)
```rust
  pub(crate) fn nonces(&self, planned_nonces: &[Vec<C::G>]) -> Vec<Vec<C::G>> {
    let mut nonces = Vec::with_capacity(planned_nonces.len());
    for n in 0 .. planned_nonces.len() {
      nonces.push(Vec::with_capacity(planned_nonces[n].len()));
      for g in 0 .. planned_nonces[n].len() {
        #[allow(non_snake_case)]
        let mut D = C::G::identity();
        let mut statements = Vec::with_capacity(self.0.len());
        #[allow(non_snake_case)]
        for IndividualBinding { commitments, binding_factors } in self.0.values() {
          D += commitments.nonces[n].generators[g].0[0];
          statements
            .push((binding_factors.as_ref().unwrap()[n], commitments.nonces[n].generators[g].0[1]));
        }
        nonces[n].push(D + multiexp_vartime(&statements));
      }
    }
    nonces
  }
```

**File:** crypto/frost/src/sign.rs (L276-281)
```rust
  fn read_preprocess<R: Read>(&self, reader: &mut R) -> io::Result<Self::Preprocess> {
    Ok(Preprocess {
      commitments: Commitments::read::<_>(reader, &self.params.algorithm.nonces())?,
      addendum: self.params.algorithm.read_addendum(reader)?,
    })
  }
```

**File:** crypto/frost/src/sign.rs (L320-320)
```rust
    let nonces = self.params.algorithm.nonces();
```

**File:** crypto/frost/src/sign.rs (L383-383)
```rust
    let Rs = B.nonces(&nonces);
```

**File:** crypto/frost/src/sign.rs (L465-466)
```rust
    if let Some(sig) = self.params.algorithm.verify(self.view.group_key(), &self.Rs, sum) {
      return Ok(sig);
```

**File:** crypto/frost/src/sign.rs (L473-489)
```rust
    let mut rng = ChaCha20Rng::from_seed(self.blame_entropy);
    let mut batch = BatchVerifier::new(self.view.included().len());
    for l in self.view.included() {
      if let Ok(statements) = self.params.algorithm.verify_share(
        self.view.verification_share(*l),
        &self.B.bound(*l),
        responses[l],
      ) {
        batch.queue(&mut rng, *l, statements);
      } else {
        Err(FrostError::InvalidShare(*l))?;
      }
    }

    if let Err(l) = batch.verify_vartime_with_vartime_blame() {
      Err(FrostError::InvalidShare(l))?;
    }
```

**File:** crypto/frost/src/sign.rs (L494-494)
```rust
    Err(FrostError::InternalError("everyone had a valid share yet the signature was still invalid"))
```

**File:** processor/src/signer.rs (L511-512)
```rust
          if !preprocess_ref.is_empty() {
            return Some(ProcessorMessage::InvalidParticipant { id, participant: l });
```

**File:** crypto/frost/src/tests/nonces.rs (L58-143)
```rust
impl<C: Curve> Algorithm<C> for MultiNonce<C> {
  type Transcript = RecommendedTranscript;
  type Addendum = ();
  type Signature = ();

  fn transcript(&mut self) -> &mut Self::Transcript {
    &mut self.transcript
  }

  fn nonces(&self) -> Vec<Vec<C::G>> {
    nonces::<C>()
  }

  fn preprocess_addendum<R: RngCore + CryptoRng>(&mut self, _: &mut R, _: &ThresholdKeys<C>) {}

  fn read_addendum<R: Read>(&self, _: &mut R) -> io::Result<Self::Addendum> {
    Ok(())
  }

  fn process_addendum(
    &mut self,
    _: &ThresholdView<C>,
    _: Participant,
    (): (),
  ) -> Result<(), FrostError> {
    Ok(())
  }

  fn sign_share(
    &mut self,
    _: &ThresholdView<C>,
    nonce_sums: &[Vec<C::G>],
    nonces: Vec<Zeroizing<C::F>>,
    _: &[u8],
  ) -> C::F {
    // Verify the nonce sums are as expected
    verify_nonces::<C>(nonce_sums);

    // Verify we actually have two nonces and that they're distinct
    assert_eq!(nonces.len(), 2);
    assert!(nonces[0] != nonces[1]);

    // Save the nonce sums for later so we can check they're consistent with the call to verify
    assert!(self.nonces.is_none());
    self.nonces = Some(nonce_sums.to_vec());

    // Sum the nonces so we can later check they actually have a relationship to nonce_sums
    let mut res = C::F::ZERO;

    // Weight each nonce
    // This is probably overkill, since their unweighted forms would practically still require
    // some level of crafting to pass a naive sum via malleability, yet this makes it more robust
    for nonce in nonce_sums {
      self.transcript.domain_separate(b"nonce");
      for commitment in nonce {
        self.transcript.append_message(b"commitment", commitment.to_bytes());
      }
    }
    let mut rng = ChaCha20Rng::from_seed(self.transcript.clone().rng_seed(b"weight"));

    for nonce in nonces {
      res += *nonce * C::F::random(&mut rng);
    }
    res
  }

  #[must_use]
  fn verify(&self, _: C::G, nonces: &[Vec<C::G>], sum: C::F) -> Option<Self::Signature> {
    verify_nonces::<C>(nonces);
    assert_eq!(&self.nonces.clone().unwrap(), nonces);

    // Make sure the nonce sums actually relate to the nonces
    let mut res = C::G::identity();
    let mut rng = ChaCha20Rng::from_seed(self.transcript.clone().rng_seed(b"weight"));
    for nonce in nonces {
      res += nonce[0] * C::F::random(&mut rng);
    }
    assert_eq!(res, C::generator() * sum);

    Some(())
  }

  fn verify_share(&self, _: C::G, _: &[Vec<C::G>], _: C::F) -> Result<Vec<(C::F, C::G)>, ()> {
    panic!("share verification triggered");
  }
}
```
