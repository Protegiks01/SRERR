### Title
Byzantine Majority Can Mint Unbacked sriBTC via Compromised Bitcoin Nodes

### Summary
Serai validators independently trust their Bitcoin node's responses when scanning for deposits, with no mechanism to verify that claimed deposits actually exist on the Bitcoin blockchain. If 2/3+ validators run compromised Bitcoin nodes or collude, they can successfully sign batches containing false deposit claims, causing Serai to mint unbacked sriBTC. This breaks the fundamental peg invariant and enables theft of funds.

### Finding Description

**Exact Code Location:**

The vulnerability spans multiple components:

1. Bitcoin RPC trusts node responses after basic validation only: [1](#0-0) 

2. Scanner emits outputs based solely on what the Bitcoin node reports: [2](#0-1) 

3. Batch creation includes all outputs from the Bitcoin node without external verification: [3](#0-2) 

4. Batch signing signs the entire batch including all instructions: [4](#0-3) 

5. Serai validates ONLY the signature, not Bitcoin blockchain state: [5](#0-4) 

**Root Cause:**

Each validator independently scans their own Bitcoin node and creates batches based on what that node reports. The FROST threshold signature protocol ensures that t-of-n validators must sign the same message, but it does NOT ensure they are signing truthful data. If 2/3+ validators' Bitcoin nodes report the same false deposits (through compromise or collusion), they will:
1. All create identical batches with false deposit instructions
2. Successfully complete the FROST signing protocol (same message = valid signature)
3. Publish the signed batch to Serai

Serai's `validate_unsigned` function verifies the signature is valid but performs ZERO verification that the claimed Bitcoin deposits actually exist on the Bitcoin blockchain.

**Why Existing Mitigations Fail:**

1. **FROST Signature Protocol**: Only prevents minority attacks. With 2/3+ compromised validators signing the same false message, the signature completes successfully. [6](#0-5) 

2. **Batch Validation**: Only checks signature validity, sequential IDs, size limits, and network matching - NOT Bitcoin blockchain state. [7](#0-6) 

3. **verify_published_batches**: Detects mismatches for honest validators but cannot prevent or slash the malicious majority. [8](#0-7) 

4. **Economic Security**: Requires automatic slashing upon detection. No mechanism exists to detect false batches or slash validators who sign them.

### Impact Explanation

**Specific Harm:**
- Attackers can mint unbacked sriBTC that has no corresponding BTC deposits on the Bitcoin blockchain
- Unbacked sriBTC can be swapped for real assets (other sriXYZ tokens, SRI) via the DEX
- Attackers can burn the swapped assets to withdraw real external coins
- Net result: theft of real user funds backed by actual external deposits

**Quantified Impact:**
The amount stolen is limited only by:
1. The batch size limit (25,000 bytes) [9](#0-8) 

2. Economic security stake requirements (but no automatic slashing mechanism exists to enforce this)

Multiple batches can be signed over time, potentially draining all liquidity.

**Severity Justification:**
This is **Critical** severity as it matches the exact criteria: "Reportedly received funds which were not actually received/spendable." The system reports Bitcoin deposits that never occurred on the Bitcoin blockchain, violating Critical Invariant #5: "minted sriXYZ equals verified external deposits."

### Likelihood Explanation

**Required Attacker Capabilities:**
1. Compromise 2/3+ validators' Bitcoin RPC nodes to return false data, OR
2. Collude with 2/3+ validators to intentionally sign false batches

**Attack Complexity:**
- **Technical Path**: Compromise Bitcoin nodes through supply chain attacks, malicious node software, or network MitM attacks. Validators likely use similar node software/infrastructure, increasing correlation.
- **Economic Path**: Bribe or collude with 2/3+ validators. Required stake is high but so is potential gain.

**Economic Feasibility:**
- Cost: Compromising nodes or bribing validators
- Gain: Unlimited unbacked sriBTC that can be swapped for real assets
- Detection: Honest minority validators will detect via `verify_published_batches` but cannot prevent or slash
- No automatic slashing means attackers may retain their stake

**Detection Risk:**
Low - Honest validators detect discrepancies but have no recourse. On-chain evidence shows valid signatures. Proving the Bitcoin deposits don't exist requires external Bitcoin blockchain verification not available on-chain.

### Recommendation

**Primary Fix: On-Chain Bitcoin State Verification**

Implement a decentralized Bitcoin light client or oracle system on Serai that:
1. Maintains Bitcoin blockchain headers
2. Requires validators to provide Merkle proofs for claimed deposits
3. Verifies proofs against the header chain before accepting batches
4. Slashes validators who submit batches without valid proofs

**Alternative Mitigations:**

1. **Multi-Client Requirement**: Require validators to run multiple independent Bitcoin node implementations and only accept outputs confirmed by all clients
2. **Challenge Period**: Implement a delay before batch execution where validators can challenge false batches with Bitcoin blockchain proofs
3. **Fraud Proofs**: Allow anyone to submit SPV proofs showing a batch's claimed deposits don't exist, triggering automatic slashing
4. **Fisherman Nodes**: Deploy dedicated monitoring nodes that verify all batches against Bitcoin blockchain and report discrepancies

**Testing Recommendations:**
1. Create test where 2/3+ validators run mock Bitcoin nodes returning false deposits
2. Verify the false batch is successfully signed and accepted
3. Implement mitigation and verify false batches are rejected
4. Test that honest minority can successfully challenge false batches

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Attacker controls 2/3+ Serai validators' Bitcoin RPC endpoints

2. **Create False Bitcoin Data**: Compromised Bitcoin nodes return a fake block containing transactions that deposit BTC to the Serai multisig:
   ```
   Block N: {
     tx: "fake_txid" depositing 100 BTC to multisig address
   }
   ```

3. **Scanner Processes False Data**: Each compromised validator's scanner reads from their node: [10](#0-9) 

4. **Batch Creation**: All compromised validators create identical batches with false deposits: [11](#0-10) 

5. **FROST Signing Succeeds**: Since 2/3+ validators sign the same (false) message, the signature is valid: [12](#0-11) 

6. **Serai Accepts Batch**: The signature verifies successfully: [13](#0-12) 

7. **False sriBTC Minted**: Instructions execute, minting 100 sriBTC with no backing

8. **Theft**: Attacker swaps unbacked sriBTC for other assets and withdraws

**Expected Behavior**: Batches should only be accepted with proof that deposits exist on Bitcoin blockchain

**Actual Behavior**: Batches are accepted based solely on valid threshold signature, regardless of whether deposits actually exist on Bitcoin blockchain

### Citations

**File:** networks/bitcoin/src/rpc.rs (L172-186)
```rust
  pub async fn get_block(&self, hash: &[u8; 32]) -> Result<Block, RpcError> {
    let hex = self.rpc_call::<String>("getblock", json!([hex::encode(hash), 0])).await?;
    let bytes: Vec<u8> = FromHex::from_hex(&hex)
      .map_err(|_| RpcError::InvalidResponse("node didn't use hex to encode the block"))?;
    let block: Block = encode::deserialize(&bytes)
      .map_err(|_| RpcError::InvalidResponse("node sent an improperly serialized block"))?;

    let mut block_hash = *block.block_hash().as_raw_hash().as_byte_array();
    block_hash.reverse();
    if hash != &block_hash {
      Err(RpcError::InvalidResponse("node replied with a different block"))?;
    }

    Ok(block)
  }
```

**File:** processor/src/multisigs/scanner.rs (L510-513)
```rust
        let Ok(block) = network.get_block(block_being_scanned).await else {
          warn!("couldn't get block {block_being_scanned}");
          break;
        };
```

**File:** processor/src/multisigs/scanner.rs (L562-567)
```rust
          for output in network.get_outputs(&block, key).await {
            assert_eq!(output.key(), key);
            if output.balance().amount.0 >= N::DUST {
              outputs.push(output);
            }
          }
```

**File:** processor/src/multisigs/mod.rs (L979-1007)
```rust
        // start with empty batch
        let mut batches = vec![Batch {
          network: N::NETWORK,
          id: batch_id,
          block: BlockHash(block_hash),
          instructions: vec![],
        }];

        for instruction in instructions {
          let batch = batches.last_mut().unwrap();
          batch.instructions.push(instruction);

          // check if batch is over-size
          if batch.encode().len() > MAX_BATCH_SIZE {
            // pop the last instruction so it's back in size
            let instruction = batch.instructions.pop().unwrap();

            // bump the id for the new batch
            batch_id += 1;

            // make a new batch with this instruction included
            batches.push(Batch {
              network: N::NETWORK,
              id: batch_id,
              block: BlockHash(block_hash),
              instructions: vec![instruction],
            });
          }
        }
```

**File:** processor/src/batch_signer.rs (L270-271)
```rust
          let (machine, share) = match machine
            .sign(preprocesses, &batch_message(&self.signable[&id]))
```

**File:** processor/src/batch_signer.rs (L357-374)
```rust
        let sig = match machine.complete(shares) {
          Ok(res) => res,
          Err(e) => match e {
            FrostError::InternalError(_) |
            FrostError::InvalidParticipant(_, _) |
            FrostError::InvalidSigningSet(_) |
            FrostError::InvalidParticipantQuantity(_, _) |
            FrostError::DuplicatedParticipant(_) |
            FrostError::MissingParticipant(_) => unreachable!(),

            FrostError::InvalidPreprocess(l) | FrostError::InvalidShare(l) => {
              return Some(
                (ProcessorMessage::InvalidParticipant { id: substrate_sign_id, participant: l })
                  .into(),
              )
            }
          },
        };
```

**File:** substrate/in-instructions/pallet/src/lib.rs (L308-323)
```rust
      // verify the signature
      let (current_session, prior, current) = keys_for_network::<T>(network)?;
      let batch_message = batch_message(&batch.batch);
      // Check the prior key first since only a single `Batch` (the last one) will be when prior is
      // Some yet prior wasn't the signing key
      let valid_by_prior =
        if let Some(key) = prior { key.verify(&batch_message, &batch.signature) } else { false };
      let valid = valid_by_prior ||
        (if let Some(key) = current {
          key.verify(&batch_message, &batch.signature)
        } else {
          false
        });
      if !valid {
        Err(InvalidTransaction::BadProof)?;
      }
```

**File:** substrate/in-instructions/pallet/src/lib.rs (L359-371)
```rust
      // Verify all Balances in this Batch are for this network
      for instruction in &batch.batch.instructions {
        // Verify this coin is for this network
        // If this is ever hit, it means the validator set has turned malicious and should be fully
        // slashed
        // Because we have an error here, no validator set which turns malicious should execute
        // this code path
        // Accordingly, there's no value in writing code to fully slash the network, when such an
        // even would require a runtime upgrade to fully resolve anyways
        if instruction.balance.coin.network() != batch.batch.network {
          Err(InvalidTransaction::Custom(2))?;
        }
      }
```

**File:** crypto/frost/src/sign.rs (L465-467)
```rust
    if let Some(sig) = self.params.algorithm.verify(self.view.group_key(), &self.Rs, sum) {
      return Ok(sig);
    }
```

**File:** coordinator/src/substrate/mod.rs (L529-542)
```rust
    if on_chain != off_chain {
      // Halt operations on this network and spin, as this is a critical fault
      loop {
        log::error!(
          "{}! network: {:?} id: {} off-chain: {} on-chain: {}",
          "on-chain batch doesn't match off-chain",
          network,
          id,
          hex::encode(off_chain),
          hex::encode(on_chain),
        );
        sleep(Duration::from_secs(60)).await;
      }
    }
```

**File:** substrate/in-instructions/primitives/src/lib.rs (L27-27)
```rust
pub const MAX_BATCH_SIZE: usize = 25_000; // ~25kb
```
